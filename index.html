<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Translator App</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/8b5cf6/ffffff?text=GT" sizes="192x192">
    <link rel="apple-touch-icon" href="https://placehold.co/512x512/8b5cf6/ffffff?text=GT" sizes="512x512">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Gemini Translator">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="./jszip.min.js"></script>
    <script src="./ejs.min.js"></script>
    <script src="./jepub.min.js"></script>
    <!-- PDF.js library for PDF parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef } from 'https://esm.sh/react@18.2.0';
        import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';
        // Importing Eye and EyeOff icons for the password toggle
        import { Download, Clipboard, Link, BookText, FileText, XCircle, Copy, Loader2, Eye, EyeOff, RefreshCcw, Save, Upload } from 'https://esm.sh/lucide-react@0.372.0';

        function App() {
          const [inputText, setInputText] = useState('');
          const [translatedText, setTranslatedText] = useState('');
          const [terminology, setTerminology] = useState('');
          const [activeTab, setActiveTab] = useState('text');
          const [loading, setLoading] = useState(false); // For translation button
          const [error, setError] = useState('');
          const [localApiKey, setLocalApiKey] = useState(() => localStorage.getItem('geminiApiKey') || '');
          const [apiKeyInput, setApiKeyInput] = localApiKey.trim().length > 0 ? useState(localApiKey) : useState('');
          const [apiKeyStatus, setApiKeyStatus] = useState('');
          const [copySuccess, setCopySuccess] = useState('');
          const [savedGlossaries, setSavedGlossaries] = useState([]);
          const [newGlossaryName, setNewGlossaryName] = useState('');
          const [activeGlossaryId, setActiveGlossaryId] = useState(null);
          const [targetLanguage, setTargetLanguage] = useState('English');
          const [showApiKey, setShowApiKey] = useState(false);
          const [downloadingPdf, setDownloadingPdf] = useState(false); // New state for PDF download loading
          const [downloadingEpub, setDownloadingEpub] = useState(false); // New state for EPUB download loading
          const [uploadingFile, setUploadingFile] = useState(false); // New state for file upload loading
          const fileInputRef = useRef(null); // Ref for the file input element

          // State for the custom modal
          const [showModal, setShowModal] = useState(false);
          const [modalMessage, setModalMessage] = useState('');
          const [modalCallback, setModalCallback] = useState(null);

          // Version state for the app
          const [version, setVersion] = useState('2.0.5'); // Updated version to 2.0.5

          const GEMINI_MODEL_NAME = 'gemini-2.0-flash';
          const BASE_GEMINI_API_URL = `https://generativelanguage.googleapis.com/v1beta/models/${GEMINI_MODEL_NAME}:generateContent`;

          const languages = [
            'English', 'Spanish', 'French', 'German', 'Italian', 'Portuguese',
            'Chinese (Simplified)', 'Japanese', 'Korean', 'Russian', 'Arabic',
            'Hindi', 'Bengali', 'Urdu', 'Vietnamese', 'Turkish', 'Polish',
            'Dutch', 'Swedish', 'Norwegian', 'Danish', 'Finnish', 'Greek',
            'Hebrew', 'Thai', 'Indonesian', 'Malay', 'Filipino', 'Romanian',
            'Hungarian', 'Czech', 'Slovak', 'Bulgarian', 'Serbian', 'Croatian',
            'Ukrainian', 'Lithuanian', 'Latvian', 'Estonian', 'Slovenian',
            'Catalan', 'Basque', 'Galician'
          ];

          useEffect(() => {
            const storedGlossaries = JSON.parse(localStorage.getItem('savedGlossaries') || '[]');
            setSavedGlossaries(storedGlossaries);

            // Set the worker source for PDF.js
            if (typeof window.pdfjsLib !== 'undefined') {
                window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
            }
          }, []);

          useEffect(() => {
            if (localApiKey) {
              setApiKeyStatus('Using your saved API key. This is saved locally, no one will be able to access it except you.');
            } else {
              setApiKeyStatus('API key is missing. A valid Gemini API key is REQUIRED for translation functionality outside of Google AI Studio (e.g., on GitHub Pages). Please enter your key below.');
            }
          }, [localApiKey]);

          const handleSaveApiKey = () => {
            if (!apiKeyInput.trim()) {
                setError('API key cannot be empty. Please enter a valid key.');
                return;
            }
            localStorage.setItem('geminiApiKey', apiKeyInput.trim());
            setLocalApiKey(apiKeyInput.trim());
            setApiKeyStatus('API key saved locally! This is required for translation outside of the Google AI Studio environment (e.g., on GitHub Pages).');
            setError('');
          };

          const handleClearApiKey = () => {
            localStorage.removeItem('geminiApiKey');
            setLocalApiKey('');
            setApiKeyInput('');
            setApiKeyStatus('API key cleared. A valid Gemini API key is REQUIRED for translation functionality outside of Google AI Studio (e.g., on GitHub Pages). Please enter your key below.');
            setError('');
          };

          // New function to handle updating a specific loaded glossary
          const handleUpdateSpecificGlossary = (glossaryName) => {
            const existingIndex = savedGlossaries.findIndex(g => g.name === glossaryName);
            if (existingIndex > -1) {
              const updatedGlossaries = [...savedGlossaries];
              updatedGlossaries[existingIndex] = { name: glossaryName, content: terminology };
              setSavedGlossaries(updatedGlossaries);
              localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
              setCopySuccess(`Glossary "${glossaryName}" updated successfully!`);
              setError('');
              setTimeout(() => setCopySuccess(''), 3000); // Clear message after 3 seconds
            } else {
              setError(`Error: Glossary "${glossaryName}" not found.`);
            }
          };

          const handleSaveGlossary = () => {
            if (!newGlossaryName.trim()) {
              setError('Please enter a name for your glossary.');
              return;
            }
            if (!terminology.trim()) {
              setError('Glossary content cannot be empty when saving.');
              return;
            }

            const existingIndex = savedGlossaries.findIndex(g => g.name === newGlossaryName.trim());
            let updatedGlossaries;

            if (existingIndex > -1) {
              setModalMessage(`A glossary named "${newGlossaryName.trim()}" already exists. Do you want to overwrite it?`);
              setModalCallback(() => {
                updatedGlossaries = [...savedGlossaries];
                updatedGlossaries[existingIndex] = { name: newGlossaryName.trim(), content: terminology };
                setSavedGlossaries(updatedGlossaries);
                localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
                setNewGlossaryName('');
                setActiveGlossaryId(newGlossaryName.trim());
                setError('');
                setShowModal(false);
              });
              setShowModal(true);
              return;
            } else {
              updatedGlossaries = [...savedGlossaries, { name: newGlossaryName.trim(), content: terminology }];
            }

            setSavedGlossaries(updatedGlossaries);
            localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
            setNewGlossaryName('');
            setActiveGlossaryId(newGlossaryName.trim());
            setError('');
          };

          const handleLoadGlossary = (glossaryToLoad) => {
            setTerminology(glossaryToLoad.content);
            setActiveGlossaryId(glossaryToLoad.name);
            setError('');
          };

          const handleDeleteGlossary = (glossaryName) => {
            setModalMessage(`Are you sure you want to delete "${glossaryName}"?`);
            setModalCallback(() => {
              const updatedGlossaries = savedGlossaries.filter(g => g.name !== glossaryName);
              setSavedGlossaries(updatedGlossaries);
              localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
              if (activeGlossaryId === glossaryName) {
                setTerminology('');
                setActiveGlossaryId(null);
              }
              setError('');
              setShowModal(false);
            });
            setShowModal(true);
          };

          // Function to clear the terminology textarea
          const handleClearTerminology = () => {
            setModalMessage('Are you sure you want to clear the current glossary text area? This will not delete saved glossaries.');
            setModalCallback(() => {
              setTerminology('');
              setActiveGlossaryId(null);
              setError('');
              setShowModal(false);
            });
            setShowModal(true);
          };

          const handleModalConfirm = () => {
            if (modalCallback) {
              modalCallback();
            }
          };

          const handleModalCancel = () => {
            setShowModal(false);
            setModalCallback(null);
          };

          // Function to paste text into the input text area
          const handlePasteInputText = async () => {
            try {
              const text = await navigator.clipboard.readText();
              setInputText(prevText => prevText + text); // Append pasted text
              setError('');
              setCopySuccess('Text pasted from clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            } catch (err) {
              setError('Failed to paste text: ' + err.message);
            }
          };

          // Function to paste text into the glossary text area
          const handlePasteTerminology = async () => {
            try {
              const text = await navigator.clipboard.readText();
              setTerminology(prevText => prevText + text); // Append pasted text
              setError('');
              setCopySuccess('Text pasted to glossary from clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            } catch (err) {
              setError('Failed to paste text: ' + err.message);
            }
          };

          // Function to paste text into the API key input area
          const handlePasteApiKey = async () => {
            try {
              const text = await navigator.clipboard.readText();
              setApiKeyInput(text); // Replace content with pasted text
              setError('');
              setCopySuccess('API key pasted from clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            } catch (err) {
              setError('Failed to paste API key: ' + err.message);
            }
          };

          // Function to copy API key to clipboard
          const handleCopyApiKey = () => {
            if (!apiKeyInput.trim()) {
              setCopySuccess('No API key to copy.');
              return;
            }
            try {
              const textarea = document.createElement('textarea');
              textarea.value = apiKeyInput;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              setCopySuccess('API key copied to clipboard!');
            } catch (err) {
              console.error('Failed to copy API key: ', err);
              setCopySuccess('Failed to copy API key. Please try again manually.');
            }
            setTimeout(() => setCopySuccess(''), 3000);
          };

          // Function to copy glossary text to clipboard
          const handleCopyTerminology = () => {
            if (!terminology.trim()) {
              setCopySuccess('No glossary text to copy.');
              return;
            }
            try {
              const textarea = document.createElement('textarea');
              textarea.value = terminology;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              setCopySuccess('Glossary text copied to clipboard!');
            } catch (err) {
              console.error('Failed to copy glossary text: ', err);
              setCopySuccess('Failed to copy glossary text. Please try again manually.');
            }
            setTimeout(() => setCopySuccess(''), 3000);
          };

          // Function to copy input text for translation to clipboard
          const handleCopyInputText = () => {
            if (!inputText.trim()) {
              setCopySuccess('No input text to copy.');
              return;
            }
            try {
              const textarea = document.createElement('textarea');
              textarea.value = inputText;
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              setCopySuccess('Input text copied to clipboard!');
            } catch (err) {
              console.error('Failed to copy input text: ', err);
              setCopySuccess('Failed to copy input text. Please try again manually.');
            }
            setTimeout(() => setCopySuccess(''), 3000);
          };

          // Function to handle file selection
          const handleFileChange = (event) => {
              const file = event.target.files[0];
              if (file) {
                  processFile(file);
              }
          };

          // Function to process the uploaded file based on its type
          const processFile = async (file) => {
              setUploadingFile(true);
              setError('');
              setInputText(''); // Clear previous text

              try {
                  const fileType = file.type;
                  let extractedText = '';

                  if (fileType === 'text/plain') {
                      extractedText = await readFileAsText(file);
                  } else if (fileType === 'application/pdf') {
                      extractedText = await readPdfFile(file);
                  } else if (fileType === 'application/epub+zip') {
                      extractedText = await readEpubFile(file);
                  } else {
                      throw new Error('Unsupported file type. Please upload a .txt, .pdf, or .epub file.');
                  }

                  setInputText(extractedText);
                  setCopySuccess(`Content extracted from ${file.name}!`);
                  setTimeout(() => setCopySuccess(''), 3000);

              } catch (err) {
                  console.error("File processing error:", err);
                  setError(`Failed to process file: ${err.message}`);
              } finally {
                  setUploadingFile(false);
                  if (fileInputRef.current) {
                      fileInputRef.current.value = ''; // Clear the file input
                  }
              }
          };

          // Helper function to read a text file
          const readFileAsText = (file) => {
              return new Promise((resolve, reject) => {
                  const reader = new FileReader();
                  reader.onload = (e) => resolve(e.target.result);
                  reader.onerror = (e) => reject(e.target.error);
                  reader.readAsText(file);
              });
          };

          // Helper function to read a PDF file
          const readPdfFile = async (file) => {
            if (typeof window.pdfjsLib === 'undefined' || typeof window.pdfjsLib.getDocument === 'undefined') {
                throw new Error('PDF.js library not loaded. Cannot process PDF files.');
            }
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';
            for (let i = 1; i <= pdf.numPages; i++) {
                const page = await pdf.getPage(i);
                const textContent = await page.getTextContent();
                fullText += textContent.items.map(item => item.str).join(' ') + '\n\n';
            }
            return fullText;
          };

          // Helper function to read an EPUB file (using JSZip)
          const readEpubFile = async (file) => {
              if (typeof window.JSZip === 'undefined') {
                  throw new Error('JSZip library not loaded. Cannot process EPUB files.');
              }

              const zip = new window.JSZip();
              const contents = await zip.loadAsync(file);
              let fullText = '';

              // 1. Find the container.xml file (usually at META-INF/container.xml)
              const containerFile = contents.file('META-INF/container.xml');
              if (!containerFile) {
                  throw new Error('EPUB error: META-INF/container.xml not found.');
              }
              const containerContent = await containerFile.async('text');
              const containerDoc = new DOMParser().parseFromString(containerContent, "text/xml");

              // Get the path to the OPF file (rootfile)
              const rootfilePath = containerDoc.querySelector('rootfile').getAttribute('full-path');
              if (!rootfilePath) {
                  throw new Error('EPUB error: Rootfile path not found in container.xml.');
              }

              // 2. Load and parse the OPF file
              const opfFile = contents.file(rootfilePath);
              if (!opfFile) {
                  throw new Error(`EPUB error: OPF file not found at ${rootfilePath}`);
              }
              const opfContent = await opfFile.async('text');
              const opfDoc = new DOMParser().parseFromString(opfContent, "text/xml");

              // Get the directory of the OPF file to resolve relative paths
              const opfDir = rootfilePath.substring(0, rootfilePath.lastIndexOf('/') + 1);

              // 3. Build a map of manifest items (id to href)
              const manifestItems = new Map();
              opfDoc.querySelectorAll('manifest item').forEach(item => {
                  manifestItems.set(item.getAttribute('id'), item.getAttribute('href'));
              });

              // 4. Iterate through the spine (reading order)
              const spine = opfDoc.querySelectorAll('spine itemref');
              for (const itemref of spine) {
                  const idref = itemref.getAttribute('idref');
                  const href = manifestItems.get(idref);

                  if (href) {
                      // Resolve the full path to the content file
                      const contentPath = opfDir + href;
                      const contentFile = contents.file(contentPath);

                      if (contentFile && contentFile.name.match(/\.(html|xhtml|htm)$/i)) {
                          try {
                              const htmlContent = await contentFile.async('text');
                              const parser = new DOMParser();
                              const doc = parser.parseFromString(htmlContent, "text/html");

                              // Remove script and style tags to get clean text
                              doc.querySelectorAll('script, style').forEach(el => el.remove());

                              // Extract text content from the body
                              fullText += doc.body.textContent || doc.body.innerText || '';
                              fullText += '\n\n'; // Add some spacing between sections
                          } catch (e) {
                              console.warn(`Could not parse or extract text from ${contentFile.name}:`, e);
                              // Continue processing other files even if one fails
                          }
                      }
                  }
              }

              if (!fullText.trim()) {
                  throw new Error('Could not extract readable text from EPUB file. No text content found in spine items.');
              }
              return fullText;
          };


          const translateContent = async (textToTranslate) => {
            setLoading(true);
            setError('');
            setTranslatedText('');

            const keyToUse = localApiKey;
            let finalApiUrl = BASE_GEMINI_API_URL;

            if (!keyToUse) {
                setError('Translation failed: A valid Gemini API key is REQUIRED. Please enter and save your key.');
                setLoading(false);
                return;
            }
            finalApiUrl = `${BASE_GEMINI_API_URL}?key=${keyToUse}`;


            let prompt = `Please translate the following text into ${targetLanguage}.`;

            if (terminology.trim()) {
              prompt += `
Use the provided Terminology Guide to ensure accuracy for specific words, names, and phrases. Words or phrases in the guide should either remain untranslated or be translated precisely as indicated within the guide's context.

---
Terminology Guide:
${terminology}
---
`;
            }

            prompt += `
Original Text to Translate:
${textToTranslate}

Provide ONLY the ${targetLanguage} translation of the Original Text to Translate. Do not include the Terminology Guide or any conversational text in your response.`;

            try {
              const chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
              const payload = { contents: chatHistory };

              const response = await fetch(finalApiUrl, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
              });

              if (!response.ok) {
                let errorDetails = `HTTP error! status: ${response.status}`;
                try {
                  const errorBody = await response.text();
                  if (errorBody) {
                    errorDetails += `, details: ${errorBody.substring(0, 200)}...`;
                  }
                } catch (e) {
                  errorDetails += `, could not read error body: ${e.message}`;
                }
                throw new Error(`API response error: ${errorDetails}`);
              }

              const responseText = await response.text();
              if (!responseText) {
                throw new Error('API returned an empty response.');
              }

              let result;
              try {
                result = JSON.parse(responseText);
              } catch (jsonParseError) {
                throw new Error(`Failed to parse API response as JSON: ${jsonParseError.message}. Response: ${responseText.substring(0, 200)}...`);
              }

              if (result && result.candidates && result.candidates.length > 0 &&
                  result.candidates[0].content && result.candidates[0].content.parts &&
                  result.candidates[0].content.parts.length > 0) {
                setTranslatedText(result.candidates[0].content.parts[0].text);
              } else {
                console.error("Unexpected API response structure:", result);
                setError('Translation failed: Unexpected API response format or no content in candidates.');
              }
            } catch (err) {
              console.error("Translation error during fetch or parsing:", err);
              setError(`Translation error: ${err.message}. Please check your input and try again. Ensure your API key is valid and has permissions.`);
            } finally {
              setLoading(false);
            }
          };

          const handlePasteTranslate = () => {
            if (inputText.trim()) {
              translateContent(inputText);
            } else {
              setError('Please paste some text to translate.');
            }
          };

          const handleClearInput = () => {
            setInputText('');
            setError('');
          };

          const handleSwapText = () => {
            const tempInput = inputText;
            setInputText(translatedText);
            setTranslatedText(tempInput);
            setError('');
          };

          const handleDownloadPDF = () => {
            if (!translatedText) {
              setError('No translated text to download.');
              return;
            }
            setDownloadingPdf(true); // Start PDF loading
            setError('');
            try {
              if (typeof window.jspdf === 'undefined' || typeof window.jspdf.jsPDF === 'undefined') {
                setError('PDF library (jsPDF) not loaded. Cannot generate PDF.');
                setDownloadingPdf(false); // End loading on error
                return;
              }
              const doc = new window.jspdf.jsPDF();
              doc.setFont('Inter', 'normal');
              doc.setFontSize(12);
              doc.setTextColor(0, 0, 0);

              const textLines = doc.splitTextToSize(translatedText, 180);
              const lineHeight = 10;
              let y = 10;

              textLines.forEach(line => {
                if (y + lineHeight > doc.internal.pageSize.height - 10) {
                  doc.addPage();
                  y = 10;
                }
                doc.text(line, 10, y);
                y += lineHeight;
              });

              doc.save(`translated_content_${targetLanguage.toLowerCase().replace(/\s/g, '-')}.pdf`);
            } catch (err) {
              console.error("PDF download error:", err);
              setError(`Failed to generate PDF: ${err.message}`);
            } finally {
              setDownloadingPdf(false); // Always end loading
            }
          };

          const handleDownloadEPUB = async () => {
            if (!translatedText) {
              setError('No translated text to download.');
              return;
            }
            setDownloadingEpub(true); // Start EPUB loading
            setError('');

            // Give the library a moment to load from the CDN
            await new Promise(resolve => setTimeout(resolve, 100));

            try {
              // Check for jEpub global object AND JSZip and ejs
              if (typeof window.jEpub === 'undefined' || typeof window.JSZip === 'undefined' || typeof window.ejs === 'undefined') {
                setError('EPUB generation libraries not loaded. Please ensure "jszip.min.js", "ejs.min.js", and "jepub.min.js" are saved in the same directory as your index.html file.');
                setDownloadingEpub(false);
                return;
              }
              const jepub = new window.jEpub();
              jepub.init({
                title: `Translated Content (${targetLanguage})`,
                author: 'Gemini Translator',
                publisher: 'Gemini Translator App',
                description: `Translated from source by Gemini Translator to ${targetLanguage}`,
                lang: targetLanguage.split(' ')[0].toLowerCase() // Use the first word of language for lang code
              });

              // --- IMPROVED EPUB CONTENT FORMATTING ---
              const paragraphs = translatedText.trim().split(/\n\s*\n+/); // Split by one or more blank lines for paragraphs
              let htmlContent = '';
              paragraphs.forEach(para => {
                if (para.trim()) {
                  const lines = para.trim().split(/\n+/); // Split remaining lines by one or more newlines within a paragraph
                  htmlContent += `<p>${lines.join('<br/>')}</p>`;
                }
              });
              // --- END IMPROVED EPUB CONTENT FORMATTING ---

              jepub.add(
                `Translation in ${targetLanguage}`,
                htmlContent
              );

              const epubBlob = await jepub.generate('blob'); // Generate as Blob for client-side download

              // Create a download link for the Blob
              const url = URL.createObjectURL(epubBlob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `translated_content_${targetLanguage.toLowerCase().replace(/\s/g, '-')}.epub`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url); // Clean up the object URL

            } catch (err) {
              console.error("EPUB download error:", err);
              setError(`Failed to generate EPUB: ${err.message}. Please ensure the jEpub library is loaded and accessible.`);
            } finally {
              setDownloadingEpub(false); // Always end loading
            }
          };

          const handleCopyToClipboard = () => {
            if (!translatedText) {
              setCopySuccess('No text to copy.');
              return;
            }
            try {
              const textarea = document.createElement('textarea');
              textarea.value = translatedText; // Copy the raw text content
              document.body.appendChild(textarea);
              textarea.select();
              document.execCommand('copy');
              document.body.removeChild(textarea);
              setCopySuccess('Translated text copied to clipboard!');
            } catch (err) {
              console.error('Failed to copy text: ', err);
              setCopySuccess('Failed to copy text. Please try again manually.');
            }
            setTimeout(() => setCopySuccess(''), 3000);
          };

          return React.createElement('div', { className: 'min-h-screen bg-gradient-to-br from-purple-500 to-indigo-700 p-4 font-sans text-gray-800 flex items-center justify-center' },
            React.createElement('div', { className: 'w-full max-w-4xl bg-white rounded-xl shadow-2xl p-8 space-y-8 backdrop-blur-md bg-opacity-90' },
              React.createElement('h1', { className: 'text-4xl font-extrabold text-center text-indigo-800 mb-2 tracking-tight' }, 'Gemini Translator'),
              React.createElement('p', { className: 'text-center text-sm text-gray-500 mb-6' }, `Version: ${version}`),

              React.createElement('div', { className: 'flex justify-center border-b border-gray-200' },
                React.createElement('button', {
                  onClick: () => setActiveTab('text'),
                  className: `py-3 px-6 text-lg font-medium rounded-t-lg transition-colors duration-200 ${activeTab === 'text' ? 'bg-indigo-600 text-white shadow-md' : 'text-indigo-700 hover:bg-indigo-100'}`
                }, React.createElement(Clipboard, { className: 'inline-block mr-2', size: 20 }), ' Text Paste'),
                React.createElement('button', {
                  onClick: () => setActiveTab('url'),
                  className: `py-3 px-6 text-lg font-medium rounded-t-lg transition-colors duration-200 ${activeTab === 'url' ? 'bg-indigo-600 text-white shadow-md' : 'text-indigo-700 hover:bg-indigo-100'}`
                }, React.createElement(Link, { className: 'inline-block mr-2', size: 20 }), ' URL (Info)')
              ),

              React.createElement('div', { className: 'bg-gray-50 p-6 rounded-b-xl rounded-r-xl shadow-inner' },
                activeTab === 'text' && React.createElement('div', { className: 'space-y-6' },
                  React.createElement('div', null,
                    React.createElement('label', { htmlFor: 'fileUpload', className: 'block text-lg font-semibold text-gray-700 mb-2' }, 'Upload File (Text, PDF, EPUB):'),
                    React.createElement('input', {
                        type: 'file',
                        id: 'fileUpload',
                        ref: fileInputRef, // Assign ref
                        onChange: handleFileChange,
                        accept: '.txt, .pdf, .epub', // Accepted file types
                        className: 'w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base mb-4',
                        disabled: uploadingFile // Disable during upload
                    }),
                    React.createElement('button', {
                        onClick: () => fileInputRef.current.click(), // Trigger file input click
                        className: 'w-full px-4 py-2 bg-purple-500 text-white font-semibold rounded-lg shadow-md hover:bg-purple-600 transition-all duration-200 hover:scale-105 flex items-center justify-center mb-4', // Added mb-4 for spacing
                        disabled: uploadingFile
                    },
                        uploadingFile ? React.createElement(Loader2, { className: 'animate-spin mr-2', size: 16 }) : React.createElement(Upload, { size: 16, className: 'mr-1' }),
                        uploadingFile ? 'Processing File...' : 'Choose and Upload File'
                    ),
                    React.createElement('label', { htmlFor: 'inputText', className: 'block text-lg font-semibold text-gray-700 mb-2' }, 'Paste Text for Translation:'),
                    React.createElement('textarea', {
                      id: 'inputText',
                      className: 'w-full p-4 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 resize-y min-h-[150px] text-base',
                      placeholder: 'Paste your content here...',
                      value: inputText,
                      onChange: (e) => setInputText(e.target.value),
                      onTouchStart: (e) => e.target.focus() // Added for mobile keyboard focus
                    }),
                    React.createElement('div', { className: 'flex flex-col gap-2 mt-2' }, // Changed to flex-col for vertical stacking
                      React.createElement('button', {
                        onClick: handlePasteInputText,
                        className: 'px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition-all duration-200 hover:scale-105 flex items-center justify-center' // Added shadow, rounded-lg, transition
                      }, React.createElement(Clipboard, { size: 16, className: 'mr-1' }), ' Paste from Clipboard'),
                      React.createElement('button', {
                        onClick: handleCopyInputText,
                        className: 'px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 transition-all duration-200 hover:scale-105 flex items-center justify-center' // Added shadow, rounded-lg, transition
                      }, React.createElement(Copy, { size: 16, className: 'mr-1' }), ' Copy Input Text'),
                      React.createElement('button', { // Moved this button to be below the copy button
                        onClick: handleClearInput,
                        className: 'w-full px-4 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition-all duration-200 hover:scale-105' // Changed to red
                      }, 'Clear Input')
                    )
                  ),
                  React.createElement('div', { className: 'flex flex-col sm:flex-row gap-2' }, // Buttons for Clear and Swap, now responsive
                    React.createElement('button', {
                      onClick: handleSwapText,
                      className: 'w-full sm:flex-1 px-4 py-2 bg-gray-200 text-gray-700 font-semibold rounded-lg shadow-md hover:bg-gray-300 transition-all duration-200 hover:scale-105 flex items-center justify-center' // Added shadow, rounded-lg, transition
                    }, React.createElement(RefreshCcw, { size: 16, className: 'mr-1' }), ' Swap Text')
                  ),
                  React.createElement('div', null,
                    React.createElement('label', { htmlFor: 'targetLanguage', className: 'block text-lg font-semibold text-gray-700 mb-2' }, 'Translate to:'),
                    React.createElement('select', {
                      id: 'targetLanguage',
                      className: 'w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base',
                      value: targetLanguage,
                      onChange: (e) => setTargetLanguage(e.target.value)
                    },
                      languages.map(lang =>
                        React.createElement('option', { key: lang, value: lang }, lang)
                      )
                    )
                  ),
                  React.createElement('button', {
                    onClick: handlePasteTranslate,
                    className: 'w-full md:w-auto md:mx-auto px-8 py-3 bg-indigo-600 text-white font-bold rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition transform hover:scale-105 flex items-center justify-center text-lg',
                    disabled: loading
                  },
                    loading ? React.createElement(Loader2, { className: 'animate-spin mr-2', size: 24 }) : React.createElement(BookText, { className: 'mr-2', size: 24 }),
                    loading ? 'Translating...' : 'Translate Text'
                  )
                ),

                activeTab === 'url' && React.createElement('div', { className: 'space-y-6' },
                  React.createElement('h2', { className: 'text-xl font-bold text-gray-800' }, 'URL Content Information'),
                  React.createElement('p', { className: 'text-gray-700 leading-relaxed' },
                    React.createElement('span', { className: 'font-semibold' }, 'Important Considerations for URL Scanning:'),
                    React.createElement('br'),
                    'Due to browser security policies (CORS) and the client-side nature of this application, direct arbitrary URL scanning and content extraction is not possible.'
                  ),
                  React.createElement('p', { className: 'text-gray-700 leading-relaxed' },
                    React.createElement('span', { className: 'font-semibold' }, 'How it would typically work with a backend:'),
                    React.createElement('br'),
                    'In a full-stack application, you would input a URL here. A backend server (e.js., Node.js, Python Flask/Django) would then:'
                  ),
                  React.createElement('ol', { className: 'list-decimal list-inside ml-4 mt-2 space-y-1 text-gray-700' },
                    React.createElement('li', null, 'Use a library like `requests` (Python) or `axios` (`Node.js`) to fetch the HTML content from the provided URL.'),
                    React.createElement('li', null, 'Parse the HTML using libraries like `BeautifulSoup` (Python) or `cheerio` (`Node.js`) to extract the main textual content.'),
                    React.createElement('li', null, 'Send this extracted text to the Gemini API for translation.'),
                    React.createElement('li', null, 'Return the translated text to the frontend.')
                  ),
                  React.createElement('p', { className: 'text-gray-700 font-semibold' }, 'For now, please manually copy content from any URL (e.g., Lofter posts) and paste it into the "Text Paste" section to utilize the translation functionality.')
                )
              ),

              React.createElement('div', { className: 'space-y-4' },
                React.createElement('label', { htmlFor: 'terminology', className: 'block text-lg font-semibold text-gray-700 mb-2' }, 'Glossary:'),
                React.createElement('textarea', {
                  id: 'terminology',
                  className: 'w-full p-3 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base resize-y min-h-[100px]',
                  placeholder: 'Paste your glossary here.',
                  value: terminology,
                  onChange: (e) => setTerminology(e.target.value),
                  onTouchStart: (e) => e.target.focus() // Added for mobile keyboard focus
                }),
                React.createElement('div', { className: 'flex flex-col gap-2 mt-2' }, // Changed to flex-col for vertical stacking
                  React.createElement('button', {
                    onClick: handlePasteTerminology,
                    className: 'px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition-all duration-200 hover:scale-105 flex items-center justify-center' // Added shadow, rounded-lg, transition
                  }, React.createElement(Clipboard, { size: 16, className: 'mr-1' }), ' Paste Glossary'),
                  React.createElement('button', {
                    onClick: handleCopyTerminology,
                    className: 'px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 transition-all duration-200 hover:scale-105 flex items-center justify-center' // Added shadow, rounded-lg, transition
                  }, React.createElement(Copy, { size: 16, className: 'mr-1' }), ' Copy Glossary'),
                  React.createElement('button', {
                    onClick: handleClearTerminology,
                    className: 'px-4 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition-all duration-200 hover:scale-105' // Added shadow, rounded-lg, transition
                  }, 'Clear Glossary')
                ),
                React.createElement('p', { className: 'text-sm text-gray-600' }, 'Enter your glossary. The translator will refer to this text to ensure specific words, names, or phrases are handled accurately.')
              ),

              React.createElement('div', { className: 'space-y-4 p-4 border border-gray-200 rounded-lg bg-gray-50' },
                React.createElement('h3', { className: 'text-xl font-bold text-gray-800' }, 'Manage Saved Glossaries'),
                React.createElement('div', { className: 'flex flex-col sm:flex-row gap-2 mb-4 items-stretch' }, // Added flex-col and sm:flex-row
                  React.createElement('input', {
                    type: 'text',
                    className: 'w-full sm:flex-grow p-2 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500', // w-full for mobile
                    placeholder: 'Name for current glossary...',
                    value: newGlossaryName,
                    onChange: (e) => setNewGlossaryName(e.target.value)
                  }),
                  React.createElement('button', {
                    onClick: handleSaveGlossary,
                    className: 'w-full sm:w-auto px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition-all duration-200 hover:scale-105' // w-full for mobile // Added shadow, rounded-lg, transition
                  }, 'Save Current Glossary')
                ),
                savedGlossaries.length > 0 && React.createElement('div', {className: 'max-h-40 overflow-y-auto pr-2'}, // Added max-height and overflow for scroll
                  React.createElement('h4', { className: 'text-lg font-semibold text-gray-700 mb-2' }, 'Your Saved Glossaries:'),
                  React.createElement('ul', { className: 'space-y-2' },
                    // Sort savedGlossaries to put the active one first
                    [...savedGlossaries].sort((a, b) => {
                      if (a.name === activeGlossaryId) return -1;
                      if (b.name === activeGlossaryId) return 1;
                      return 0;
                    }).map((glossary, index) =>
                      React.createElement('li', { key: index, className: 'flex flex-wrap items-center justify-between p-3 bg-white border border-gray-200 rounded-lg shadow-sm' }, // Added flex-wrap // Added shadow, rounded-lg
                        React.createElement('span', { className: `font-medium ${activeGlossaryId === glossary.name ? 'text-indigo-700' : 'text-gray-800'} mb-2 sm:mb-0` }, glossary.name), // Added margin for spacing
                        React.createElement('div', { className: 'flex flex-col w-full sm:w-auto sm:flex-row gap-2' }, // Added w-full here to stretch container, and sm:w-auto to revert on larger screens
                          React.createElement('button', {
                            onClick: () => handleLoadGlossary(glossary),
                            className: 'px-3 py-1 text-sm bg-blue-500 text-white rounded-lg shadow-md hover:bg-blue-600 transition-all duration-200 hover:scale-105 w-full' // Added w-full
                          }, 'Load'),
                          activeGlossaryId === glossary.name && React.createElement('button', {
                            onClick: () => handleUpdateSpecificGlossary(glossary.name),
                            className: 'px-3 py-1 text-sm bg-green-500 text-white rounded-lg shadow-md hover:bg-green-600 transition-all duration-200 hover:scale-105 flex items-center justify-center w-full' // Added w-full
                          }, React.createElement(Save, { size: 14, className: 'mr-1' }), ' Save Edits'),
                          React.createElement('button', {
                            onClick: () => handleDeleteGlossary(glossary.name),
                            className: 'px-3 py-1 text-sm bg-red-500 text-white rounded-lg shadow-md hover:bg-red-600 transition-all duration-200 hover:scale-105 w-full' // Added w-full
                          }, 'Delete')
                        )
                      )
                    )
                  )
                )
              ),

              React.createElement('div', { className: 'space-y-4' },
                React.createElement('label', { htmlFor: 'apiKeyInput', className: 'block text-lg font-semibold text-gray-700 mb-2' }, 'Your Gemini API Key (Required):'),
                React.createElement('div', { className: 'relative flex items-center' }, // Flex container for input and toggle
                    React.createElement('input', { // Changed from textarea to input
                        id: 'apiKeyInput',
                        type: showApiKey ? 'text' : 'password', // Toggle type based on state
                        className: 'w-full p-3 pr-10 border border-gray-300 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base',
                        placeholder: 'Paste your Gemini API key here...',
                        value: apiKeyInput,
                        onChange: (e) => setApiKeyInput(e.target.value),
                        onTouchStart: (e) => e.target.focus() // Added for mobile keyboard focus
                    }),
                    React.createElement('button', {
                        type: 'button', // Prevent form submission
                        onClick: () => setShowApiKey(!showApiKey),
                        className: 'absolute right-3 p-1 rounded-full text-gray-500 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-indigo-500'
                    },
                        showApiKey ? React.createElement(EyeOff, { size: 20 }) : React.createElement(Eye, { size: 20 })
                    )
                ),
                React.createElement('div', { className: 'flex flex-col gap-2 mt-2' }, // Changed to flex-col for vertical stacking
                  React.createElement('button', {
                    onClick: handleSaveApiKey,
                    className: 'px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition-all duration-200 hover:scale-105' // Added shadow, rounded-lg, transition
                  }, 'Save API Key'),
                  React.createElement('button', {
                    onClick: handlePasteApiKey, // New paste button for API key
                    className: 'px-4 py-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition-all duration-200 hover:scale-105 flex items-center justify-center' // Added shadow, rounded-lg, transition
                  }, React.createElement(Clipboard, { size: 16, className: 'mr-1' }), ' Paste API Key'),
                  React.createElement('button', {
                    onClick: handleCopyApiKey,
                    className: 'px-4 py-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 transition-all duration-200 hover:scale-105 flex items-center justify-center' // Added shadow, rounded-lg, transition
                  }, React.createElement(Copy, { size: 16, className: 'mr-1' }), ' Copy API Key'),
                  React.createElement('button', {
                    onClick: handleClearApiKey,
                    className: 'px-4 py-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition-all duration-200 hover:scale-105' // Changed bg-yellow-500 to bg-red-500 and hover:bg-yellow-600 to hover:bg-red-600
                  }, 'Clear API Key')
                ),
                React.createElement('p', { className: 'text-sm text-gray-600 mt-2' }, apiKeyStatus),
              ),


              error && React.createElement('div', { className: 'bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md shadow-md flex items-center animate-fade-in-down' },
                React.createElement(XCircle, { className: 'mr-3 cursor-pointer', size: 20, onClick: () => setError('') }), // Dismiss button
                React.createElement('p', { className: 'font-medium' }, error)
              ),

              translatedText && React.createElement('div', { className: 'space-y-6' },
                React.createElement('div', null,
                  React.createElement('label', { htmlFor: 'translatedText', className: 'block text-lg font-semibold text-gray-700 mb-2' }, `Translated Content (${targetLanguage}):`),
                  React.createElement('textarea', {
                    id: 'translatedText',
                    className: 'w-full p-4 border border-green-300 bg-green-50 rounded-lg shadow-inner focus:outline-none resize-y min-h-[200px] text-base',
                    readOnly: true,
                    value: translatedText
                  })
                ),
                copySuccess && React.createElement('p', { className: 'text-sm text-green-700 mt-2 text-center' }, copySuccess),
                React.createElement('div', { className: 'flex flex-col sm:flex-row justify-center gap-4' }, // Still horizontal on sm+ for main download buttons
                  React.createElement('button', {
                    onClick: handleCopyToClipboard,
                    className: 'w-full sm:w-auto px-6 py-3 bg-blue-500 text-white font-bold rounded-full shadow-lg hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 transition transform hover:scale-105 flex items-center justify-center text-lg'
                  }, React.createElement(Copy, { className: 'mr-2', size: 20 }), ' Copy Translation'),
                  React.createElement('button', {
                    onClick: handleDownloadEPUB,
                    className: 'w-full sm:w-auto px-6 py-3 bg-teal-500 text-white font-bold rounded-full shadow-lg hover:bg-teal-600 focus:outline-none focus:ring-4 focus:ring-teal-300 transition transform hover:scale-105 flex items-center justify-center text-lg',
                    disabled: downloadingEpub // Disable during download
                  },
                    downloadingEpub ? React.createElement(Loader2, { className: 'animate-spin mr-2', size: 20 }) : React.createElement(Download, { className: 'mr-2', size: 20 }),
                    downloadingEpub ? 'Generating EPUB...' : 'Download EPUB'
                  ),
                  React.createElement('button', {
                    onClick: handleDownloadPDF,
                    className: 'w-full sm:w-auto px-6 py-3 bg-red-500 text-white font-bold rounded-full shadow-lg hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300 transition transform hover:scale-105 flex items-center justify-center text-lg',
                    disabled: downloadingPdf // Disable during download
                  },
                    downloadingPdf ? React.createElement(Loader2, { className: 'animate-spin mr-2', size: 20 }) : React.createElement(Download, { className: 'mr-2', size: 20 }),
                    downloadingPdf ? 'Generating PDF...' : 'Download PDF'
                  )
                )
              ),

              // Custom Modal Component
              showModal && React.createElement('div', { className: 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4' },
                React.createElement('div', { className: 'bg-white rounded-lg shadow-xl p-6 max-w-sm w-full space-y-4' },
                  React.createElement('p', { className: 'text-lg font-semibold text-gray-800 text-center' }, modalMessage),
                  React.createElement('div', { className: 'flex justify-center gap-4 mt-4' },
                    React.createElement('button', {
                      onClick: handleModalConfirm,
                      className: 'px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors'
                    }, 'Confirm'),
                    React.createElement('button', {
                      onClick: handleModalCancel,
                      className: 'px-6 py-2 bg-gray-300 text-gray-800 rounded-md hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors'
                    }, 'Cancel')
                  )
                )
              )
            )
          );
        }

        const rootElement = document.getElementById('root');
        if (rootElement) {
            ReactDOM.createRoot(rootElement).render(React.createElement(App));
        } else {
            console.error('Root element not found to render React app.');
        }

        // Register Service Worker
        if ('serviceWorker' in navigator) {
          window.addEventListener('load', () => {
            navigator.serviceWorker.register('/service-worker.js')
              .then(registration => {
                console.log('Service Worker registered with scope:', registration.scope);
              })
              .catch(error => {
                console.error('Service Worker registration failed:', error);
              });
          });
        }
    </script>
</body>
</html>
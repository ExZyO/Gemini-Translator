<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gemini Translator</title>
    <link rel="manifest" href="./manifest.json">
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/8b5cf6/ffffff?text=GT" sizes="192x192">
    <link rel="apple-touch-icon" href="https://placehold.co/512x512/8b5cf6/ffffff?text=GT" sizes="512x512">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Gemini Translator">

    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://unpkg.com/jspdf@4.0.0/dist/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ejs/3.1.10/ejs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jepub@2.5.0/dist/jepub.min.js"></script>
    <script src="https://unpkg.com/mammoth@1.8.0/mammoth.browser.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="module">
        import React, { useState, useEffect, useRef, memo } from 'https://esm.sh/react@19.2.0';
        import ReactDOM from 'https://esm.sh/react-dom@19.2.0/client';
        import { Download, Clipboard, Link, BookText, FileText, XCircle, Copy, Loader2, Eye, EyeOff, RefreshCcw, Save, Upload, Moon, Sun } from 'https://esm.sh/lucide-react@0.562.0';

        function App() {
          const [inputText, setInputText] = useState('');
          const [assembledTranslatedText, setAssembledTranslatedText] = useState('');
          const [terminology, setTerminology] = useState('');
          const [activeTab, setActiveTab] = useState('text');
          const [isTextTranslating, setIsTextTranslating] = useState(false);
          const [textTranslationProgress, setTextTranslationProgress] = useState(0);
          const [isEbookTranslating, setIsEbookTranslating] = useState(false);
          const [ebookTranslationProgress, setEbookTranslationProgress] = useState(0);
          const [ebookTranslationStatus, setEbookTranslationStatus] = useState('');
          const [error, setError] = useState('');
          const [localApiKey, setLocalApiKey] = useState(() => localStorage.getItem('geminiApiKey') || '');
          const [apiKeyInput, setApiKeyInput] = useState(() => localStorage.getItem('geminiApiKey') || '');
          const [apiKeyStatus, setApiKeyStatus] = useState('');
          const [copySuccess, setCopySuccess] = useState('');
          const [savedGlossaries, setSavedGlossaries] = useState([]);
          const [newGlossaryName, setNewGlossaryName] = useState('');
          const [activeGlossaryId, setActiveGlossaryId] = useState(null);
          const [targetLanguage, setTargetLanguage] = useState('English');
          const [showApiKey, setShowApiKey] = useState(false);
          const [downloadingPdf, setDownloadingPdf] = useState(false);
          const [downloadingEpub, setDownloadingEpub] = useState(false);
          const [uploadingFile, setUploadingFile] = useState(false);
          const fileInputRef = useRef(null);
          const glossaryFileInputRef = useRef(null);
          const [defaultGlossaryName, setDefaultGlossaryName] = useState(() => localStorage.getItem('defaultGlossaryName') || null);
          const [translatedChapters, setTranslatedChapters] = useState([]);
          const [isDarkMode, setIsDarkMode] = useState(() => localStorage.getItem('darkMode') === 'true');
          const [showModal, setShowModal] = useState(false);
          const [modalMessage, setModalMessage] = useState('');
          const [modalCallback, setModalCallback] = useState(null);
          const [version, setVersion] = useState('3.8.0');
          const [geminiModel, setGeminiModel] = useState(() => localStorage.getItem('geminiModel') || 'gemini-3-flash');

          const languages = [
            'English', 'Spanish', 'French', 'German', 'Italian', 'Portuguese',
            'Chinese (Simplified)', 'Japanese', 'Korean', 'Russian', 'Arabic',
            'Hindi', 'Bengali', 'Urdu', 'Vietnamese', 'Turkish', 'Polish',
            'Dutch', 'Swedish', 'Norwegian', 'Danish', 'Finnish', 'Greek',
            'Hebrew', 'Thai', 'Indonesian', 'Malay', 'Filipino', 'Romanian',
            'Hungarian', 'Czech', 'Slovak', 'Bulgarian', 'Serbian', 'Croatian',
            'Ukrainian', 'Lithuanian', 'Latvian', 'Estonian', 'Slovenian',
            'Catalan', 'Basque', 'Galician'
          ];

          useEffect(() => {
            document.documentElement.classList.toggle('dark', isDarkMode);
            localStorage.setItem('darkMode', isDarkMode);
          }, [isDarkMode]);

          useEffect(() => {
            const storedGlossaries = JSON.parse(localStorage.getItem('savedGlossaries') || '[]');
            setSavedGlossaries(storedGlossaries);

            const storedModel = localStorage.getItem('geminiModel');
            if (storedModel) {
              setGeminiModel(storedModel);
            }

            const storedDefaultGlossaryName = localStorage.getItem('defaultGlossaryName');
            if (storedDefaultGlossaryName) {
              setDefaultGlossaryName(storedDefaultGlossaryName);
              const defaultGlossary = storedGlossaries.find(g => g.name === storedDefaultGlossaryName);
              if (defaultGlossary) {
                setTerminology(defaultGlossary.content);
                setActiveGlossaryId(defaultGlossary.name);
                setError('');
              } else {
                localStorage.removeItem('defaultGlossaryName');
                setDefaultGlossaryName(null);
              }
            }

            if (typeof window.pdfjsLib !== 'undefined') {
              window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.7.76/pdf.worker.min.js';
            } else {
              console.warn('PDF.js library not detected.');
            }
          }, []);

          useEffect(() => {
            if (localApiKey) {
              setApiKeyStatus('Using your saved API key. This is saved locally, no one will be able to access it except you.');
            } else {
              setApiKeyStatus('API key is missing. A valid Gemini API key is REQUIRED for translation functionality. Please enter your key below.');
            }
          }, [localApiKey]);

          const handleSaveApiKey = () => {
            if (!apiKeyInput.trim()) {
              setError('API key cannot be empty. Please enter a valid key.');
              return;
            }
            localStorage.setItem('geminiApiKey', apiKeyInput.trim());
            setLocalApiKey(apiKeyInput.trim());
            setApiKeyStatus('API key saved locally!');
            setError('');
          };

          const handleClearApiKey = () => {
            localStorage.removeItem('geminiApiKey');
            setLocalApiKey('');
            setApiKeyInput('');
            setApiKeyStatus('API key cleared. A valid Gemini API key is REQUIRED for translation functionality. Please enter your key below.');
            setError('');
          };

          const handleUpdateSpecificGlossary = (glossaryName) => {
            const existingIndex = savedGlossaries.findIndex(g => g.name === glossaryName);
            if (existingIndex > -1) {
              const updatedGlossaries = [...savedGlossaries];
              updatedGlossaries[existingIndex] = { name: glossaryName, content: terminology };
              setSavedGlossaries(updatedGlossaries);
              localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
              setCopySuccess(`Glossary "${glossaryName}" updated successfully!`);
              setError('');
              setTimeout(() => setCopySuccess(''), 3000);
            } else {
              setError(`Error: Glossary "${glossaryName}" not found.`);
            }
          };

          const handleSaveGlossary = () => {
            if (!newGlossaryName.trim()) {
              setError('Please enter a name for your glossary.');
              return;
            }
            if (!terminology.trim()) {
              setError('Glossary content cannot be empty when saving.');
              return;
            }

            const existingIndex = savedGlossaries.findIndex(g => g.name === newGlossaryName.trim());
            let updatedGlossaries;

            if (existingIndex > -1) {
              setModalMessage(`A glossary named "${newGlossaryName.trim()}" already exists. Do you want to overwrite it?`);
              setModalCallback(() => () => {
                updatedGlossaries = [...savedGlossaries];
                updatedGlossaries[existingIndex] = { name: newGlossaryName.trim(), content: terminology };
                setSavedGlossaries(updatedGlossaries);
                localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
                setNewGlossaryName('');
                setActiveGlossaryId(newGlossaryName.trim());
                setError('');
                setShowModal(false);
              });
              setShowModal(true);
              return;
            } else {
              updatedGlossaries = [...savedGlossaries, { name: newGlossaryName.trim(), content: terminology }];
            }

            setSavedGlossaries(updatedGlossaries);
            localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
            setNewGlossaryName('');
            setActiveGlossaryId(newGlossaryName.trim());
            setError('');
          };

          const handleLoadGlossary = (glossaryToLoad) => {
            setTerminology(glossaryToLoad.content);
            setActiveGlossaryId(glossaryToLoad.name);
            setError('');
          };

          const handleDeleteGlossary = (glossaryName) => {
            setModalMessage(`Are you sure you want to delete "${glossaryName}"?`);
            setModalCallback(() => () => {
              const updatedGlossaries = savedGlossaries.filter(g => g.name !== glossaryName);
              setSavedGlossaries(updatedGlossaries);
              localStorage.setItem('savedGlossaries', JSON.stringify(updatedGlossaries));
              if (activeGlossaryId === glossaryName) {
                setTerminology('');
                setActiveGlossaryId(null);
              }
              if (defaultGlossaryName === glossaryName) {
                localStorage.removeItem('defaultGlossaryName');
                setDefaultGlossaryName(null);
              }
              setError('');
              setShowModal(false);
            });
            setShowModal(true);
          };

          const handleSetDefaultGlossary = () => {
            if (activeGlossaryId) {
              localStorage.setItem('defaultGlossaryName', activeGlossaryId);
              setDefaultGlossaryName(activeGlossaryId);
              setCopySuccess(`"${activeGlossaryId}" set as default glossary!`);
              setError('');
              setTimeout(() => setCopySuccess(''), 3000);
            } else {
              setError('Please load a glossary first to set it as default.');
            }
          };

          const handleClearDefaultGlossary = () => {
            setModalMessage('Are you sure you want to clear the default glossary setting?');
            setModalCallback(() => () => {
              localStorage.removeItem('defaultGlossaryName');
              setDefaultGlossaryName(null);
              setCopySuccess('Default glossary setting cleared!');
              setError('');
              setShowModal(false);
              setTimeout(() => setCopySuccess(''), 3000);
            });
            setShowModal(true);
          };

          const handleClearTerminology = () => {
            setModalMessage('Are you sure you want to clear the current glossary text area? This will not delete saved glossaries.');
            setModalCallback(() => () => {
              setTerminology('');
              setActiveGlossaryId(null);
              setError('');
              setShowModal(false);
            });
            setShowModal(true);
          };

          const handleModalConfirm = () => {
            if (modalCallback) {
              modalCallback();
            }
          };

          const handleModalCancel = () => {
            setShowModal(false);
            setModalCallback(null);
          };

          const handlePasteInputText = async () => {
            try {
              const text = await navigator.clipboard.readText();
              setInputText(prevText => prevText + text);
              setError('');
              setCopySuccess('Text pasted from clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            } catch (err) {
              setError('Failed to paste text: ' + err.message);
            }
          };

          const handlePasteTerminology = async () => {
            try {
              const text = await navigator.clipboard.readText();
              setTerminology(prevText => prevText + text);
              setError('');
              setCopySuccess('Text pasted to glossary from clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            } catch (err) {
              setError('Failed to paste text: ' + err.message);
            }
          };

          const handlePasteApiKey = async () => {
            try {
              const text = await navigator.clipboard.readText();
              setApiKeyInput(text);
              setError('');
              setCopySuccess('API key pasted from clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            } catch (err) {
              setError('Failed to paste API key: ' + err.message);
            }
          };

          const handleCopyApiKey = () => {
            if (!apiKeyInput.trim()) {
              setCopySuccess('No API key to copy.');
              return;
            }
            navigator.clipboard.writeText(apiKeyInput).then(() => {
              setCopySuccess('API key copied to clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            }).catch(err => {
              setCopySuccess('Failed to copy API key.');
            });
          };

          const handleCopyTerminology = () => {
            if (!terminology.trim()) {
              setCopySuccess('No glossary text to copy.');
              return;
            }
            navigator.clipboard.writeText(terminology).then(() => {
              setCopySuccess('Glossary text copied to clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            }).catch(err => {
              setCopySuccess('Failed to copy glossary text.');
            });
          };

          const handleCopyInputText = () => {
            if (!inputText.trim()) {
              setCopySuccess('No input text to copy.');
              return;
            }
            navigator.clipboard.writeText(inputText).then(() => {
              setCopySuccess('Input text copied to clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            }).catch(err => {
              setCopySuccess('Failed to copy input text.');
            });
          };

          const handleCopyToClipboard = () => {
            if (!assembledTranslatedText) {
              setCopySuccess('No text to copy.');
              return;
            }
            navigator.clipboard.writeText(assembledTranslatedText).then(() => {
              setCopySuccess('Translated text copied to clipboard!');
              setTimeout(() => setCopySuccess(''), 3000);
            }).catch(err => {
              setCopySuccess('Failed to copy text.');
            });
          };

          const handleGlossaryFileButtonClick = () => {
            glossaryFileInputRef.current.click();
          };

          const handleGlossaryFileChange = async (event) => {
            const file = event.target.files[0];
            if (!file) return;
            const allowedTypes = ['text/plain', 'text/markdown', 'application/json', 'text/csv', 'application/xml', 'text/html'];
            if (!allowedTypes.includes(file.type) && !file.name.match(/\.(txt|md|json|csv|xml|html)$/i)) {
              setError('Unsupported glossary file type.');
              return;
            }
            setUploadingFile(true);
            setError('');
            try {
              const reader = new FileReader();
              reader.onload = (e) => {
                const fileContent = e.target.result;
                setTerminology(fileContent);
                setNewGlossaryName(file.name.split('.').slice(0, -1).join('.'));
                setCopySuccess(`Glossary loaded from ${file.name}!`);
                setTimeout(() => setCopySuccess(''), 3000);
                setUploadingFile(false);
              };
              reader.readAsText(file);
            } catch (err) {
              setError('Failed to process glossary file: ' + err.message);
              setUploadingFile(false);
            } finally {
              glossaryFileInputRef.current.value = '';
            }
          };

          const MAX_PAYLOAD_LENGTH = 15000;
          const TOKEN_RATIO = 4;

          const splitIntoChunks = (text) => {
            const promptTemplateOverhead = 800;
            const glossaryLength = terminology.trim().length;
            let effectiveMaxChunkLength = MAX_PAYLOAD_LENGTH - promptTemplateOverhead - glossaryLength;

            const estimatedTokens = (effectiveMaxChunkLength / TOKEN_RATIO);
            if (estimatedTokens < 50) {
              effectiveMaxChunkLength = 200;
            }

            const chunks = [];
            let remainingText = text;

            while (remainingText.length > 0) {
              if (remainingText.length <= effectiveMaxChunkLength) {
                chunks.push(remainingText);
                break;
              }

              let splitPoint = effectiveMaxChunkLength;
              let doubleNewlineIndex = remainingText.lastIndexOf('\n\n', effectiveMaxChunkLength);
              if (doubleNewlineIndex !== -1 && doubleNewlineIndex > effectiveMaxChunkLength * 0.7) {
                splitPoint = doubleNewlineIndex + 2;
              } else {
                let singleNewlineIndex = remainingText.lastIndexOf('\n', effectiveMaxChunkLength);
                if (singleNewlineIndex !== -1 && singleNewlineIndex > effectiveMaxChunkLength * 0.7) {
                  splitPoint = singleNewlineIndex + 1;
                } else {
                  let sentenceEndIndex = Math.max(
                    remainingText.lastIndexOf('.', effectiveMaxChunkLength),
                    remainingText.lastIndexOf('?', effectiveMaxChunkLength),
                    remainingText.lastIndexOf('!', effectiveMaxChunkLength)
                  );
                  if (sentenceEndIndex !== -1 && sentenceEndIndex > effectiveMaxChunkLength * 0.7) {
                    splitPoint = sentenceEndIndex + 1;
                  }
                }
              }

              if (splitPoint <= 0) {
                splitPoint = effectiveMaxChunkLength;
              }

              chunks.push(remainingText.substring(0, splitPoint));
              remainingText = remainingText.substring(splitPoint).trimStart();
            }
            return chunks;
          };

          const translateChunk = async (textToTranslate, retryCount = 0) => {
            const keyToUse = localApiKey;
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${geminiModel}:generateContent?key=${keyToUse}`;

            let basePrompt = `Please translate the following text into ${targetLanguage}. IMPORTANT: Preserve all original paragraph breaks (double newlines) and line breaks (single newlines) exactly as they appear in the original text. The translated text's structure must mirror the original's structure.\n\n${textToTranslate}\n\nProvide ONLY the ${targetLanguage} translation. Do not add any extra commentary, greetings, or explanations.`;
            
            let promptWithGlossary = basePrompt;
            if (terminology.trim()) {
                promptWithGlossary = `Use the provided Terminology Guide for specific terms.\n---\nTerminology Guide:\n${terminology.trim()}\n---\n\n` + basePrompt;
            }

            try {
                const chatHistory = [{ role: "user", parts: [{ text: promptWithGlossary }] }];
                const payload = { contents: chatHistory };

                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });

                if (!response.ok) {
                    if (response.status === 429 && retryCount < 3) {
                        await new Promise(resolve => setTimeout(resolve, 2000 * (retryCount + 1)));
                        return translateChunk(textToTranslate, retryCount + 1);
                    }
                    let errorDetails = `HTTP error! status: ${response.status}`;
                    const errorBody = await response.text();
                    errorDetails += `, details: ${errorBody.substring(0, 200)}...`;
                    throw new Error(errorDetails);
                }

                const result = await response.json();

                if (result.candidates && result.candidates[0].content && result.candidates[0].content.parts) {
                    return result.candidates[0].content.parts[0].text;
                } else {
                    throw new Error('Unexpected API response format.');
                }
            } catch (err) {
                throw new Error(`Translation error: ${err.message}.`);
            }
          };

          const processBatches = async (items, processFn, batchSize = 3) => {
            const results = [];
            for (let i = 0; i < items.length; i += batchSize) {
              const batch = items.slice(i, i + batchSize);
              const batchResults = await Promise.all(batch.map(processFn));
              results.push(...batchResults);
              await new Promise(resolve => setTimeout(resolve, 500));
            }
            return results;
          };

          const translateEbook = async (chaptersToTranslate) => {
            setIsEbookTranslating(true);
            setEbookTranslationProgress(0);
            setError('');
            setAssembledTranslatedText('');
            setTranslatedChapters([]);
            setEbookTranslationStatus('');

            const allTranslatedPartsForDisplay = [];
            const newTranslatedChapters = [];
            
            try {
                let totalChunks = 0;
                const chapterChunks = chaptersToTranslate.map(chap => {
                    const chunks = splitIntoChunks(chap.text);
                    totalChunks += chunks.length;
                    if (chap.title.trim()) totalChunks += 1;
                    return chunks;
                });
                let processedChunks = 0;

                if (!chaptersToTranslate || chaptersToTranslate.length === 0) {
                    setError('No content to translate from the file.');
                    setIsEbookTranslating(false);
                    return;
                }

                for (let i = 0; i < chaptersToTranslate.length; i++) {
                    setEbookTranslationStatus(`Translating chapter ${i + 1}/${chaptersToTranslate.length}: "${chaptersToTranslate[i].title}"`);
                    const chapter = chaptersToTranslate[i];
                    let translatedChapterTitle = chapter.title;

                    if (chapter.title.trim()) {
                        translatedChapterTitle = await translateChunk(chapter.title);
                        processedChunks++;
                        setEbookTranslationProgress(Math.floor((processedChunks / totalChunks) * 100));
                    }

                    const chunks = chapterChunks[i];
                    const translatedChapterChunks = await processBatches(chunks, translateChunk);
                    processedChunks += chunks.length;
                    setEbookTranslationProgress(Math.floor((processedChunks / totalChunks) * 100));
                    
                    const normalizedTranslatedChapter = translatedChapterChunks.join('').replace(/\r\n/g, '\n').trim();

                    newTranslatedChapters.push({
                        originalTitle: chapter.title,
                        title: translatedChapterTitle,
                        content: normalizedTranslatedChapter
                    });

                    allTranslatedPartsForDisplay.push(`${translatedChapterTitle}\n\n${normalizedTranslatedChapter}`);
                }
                
                setTranslatedChapters(newTranslatedChapters);
                const finalAssembledText = allTranslatedPartsForDisplay.join('\n\n\n').trim();
                setAssembledTranslatedText(finalAssembledText);

            } catch (err) {
                setError(`Ebook translation failed: ${err.message}`);
                setAssembledTranslatedText('Translation failed for the ebook.');
                setTranslatedChapters([]);
            } finally {
                setIsEbookTranslating(false);
                setEbookTranslationProgress(0);
                setEbookTranslationStatus('');
            }
          };

          const handleTranslateFromInputText = async () => {
              setIsTextTranslating(true);
              setTextTranslationProgress(0);
              setError('');
              setAssembledTranslatedText('');
              setTranslatedChapters([]);

              if (!inputText.trim()) {
                  setError('Please paste some text to translate.');
                  setIsTextTranslating(false);
                  return;
              }

              try {
                  const chunks = splitIntoChunks(inputText);
                  const totalChunks = chunks.length;
                  const translatedChunks = await processBatches(chunks, translateChunk);
                  setTextTranslationProgress(100);
                  
                  const normalizedTranslated = translatedChunks.join('').replace(/\r\n/g, '\n').trim();
                  setAssembledTranslatedText(normalizedTranslated);
                  setTranslatedChapters([{ title: 'Translated Document', content: normalizedTranslated }]);
              } catch (err) {
                  setError(err.message);
              } finally {
                  setIsTextTranslating(false);
                  setTextTranslationProgress(0);
              }
          };

          const handleClearInput = () => {
            setInputText('');
            setError('');
            setAssembledTranslatedText('');
            setTranslatedChapters([]);
          };

          const handleSwapText = () => {
            const tempInput = inputText;
            setInputText(assembledTranslatedText);
            setAssembledTranslatedText(tempInput);
            setError('');
          };

          const cleanExtractedText = (text) => {
            let cleanedText = text.replace(/\r\n|\r/g, '\n').replace(/[ \t]{2,}/g, ' ').replace(/(\n\s*){2,}/g, '\n\n').trim();
            return cleanedText;
          };

          const handleFileChange = async (event) => {
            const file = event.target.files[0];
            if (file) {
              if (file.size > 50 * 1024 * 1024) {
                setError('File too large. Maximum size is 50MB.');
                return;
              }
              await processFile(file);
            }
          };

          const processFile = async (file) => {
            setUploadingFile(true);
            setError('');
            setInputText('');
            setAssembledTranslatedText('');
            setTranslatedChapters([]);

            try {
              const fileType = file.type;
              let extractedData;
              
              if (fileType === 'text/plain') {
                const rawText = await readFileAsText(file);
                extractedData = { chapters: [{ title: file.name || 'Document', text: rawText }] };
              } else if (fileType === 'application/pdf') {
                const rawText = await readPdfFile(file);
                extractedData = { chapters: [{ title: file.name || 'PDF Document', text: rawText }] };
              } else if (fileType === 'application/epub+zip') {
                extractedData = await readEpubFile(file);
              } else if (fileType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                const arrayBuffer = await file.arrayBuffer();
                const result = await mammoth.extractRawText({arrayBuffer});
                extractedData = { chapters: [{ title: file.name || 'DOCX Document', text: result.value }] };
              } else {
                throw new Error('Unsupported file type. Please upload a .txt, .pdf, .epub, or .docx file.');
              }
              
              const cleanedChapters = extractedData.chapters.map(chap => ({
                ...chap,
                text: cleanExtractedText(chap.text)
              }));

              setCopySuccess(`Content extracted from ${file.name}! Starting translation...`);
              setTimeout(() => setCopySuccess(''), 3000);
              await translateEbook(cleanedChapters);

            } catch (err) {
              setError(`Failed to process file: ${err.message}`);
            } finally {
              setUploadingFile(false);
              fileInputRef.current.value = '';
            }
          };

          const readFileAsText = (file) => {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (e) => resolve(e.target.result);
              reader.onerror = (e) => reject(e.target.error);
              reader.readAsText(file);
            });
          };

          const readPdfFile = async (file) => {
            const arrayBuffer = await file.arrayBuffer();
            const pdf = await window.pdfjsLib.getDocument({ data: arrayBuffer }).promise;
            let fullText = '';
            
            for (let i = 1; i <= pdf.numPages; i++) {
              const page = await pdf.getPage(i);
              const textContent = await page.getTextContent();
              if (!textContent.items || textContent.items.length === 0) continue;

              const sortedItems = textContent.items.sort((a, b) => {
                if (a.transform[5] < b.transform[5]) return 1;
                if (a.transform[5] > b.transform[5]) return -1;
                return a.transform[4] - b.transform[4];
              });

              let lastY = sortedItems[0].transform[5];
              let lineText = '';

              for (const item of sortedItems) {
                const currentY = item.transform[5];
                if (Math.abs(currentY - lastY) > item.height * 0.4) {
                  fullText += lineText + '\n';
                  if (Math.abs(currentY - lastY) > item.height * 1.2) {
                    fullText += '\n';
                  }
                  lineText = '';
                }
                lineText += item.str;
                if (!item.str.endsWith(' ')) {
                  lineText += ' ';
                }
                lastY = currentY;
              }
              fullText += lineText + '\n\n';
            }
            return fullText;
          };

          const readEpubFile = async (file) => {
            const zip = await window.JSZip.loadAsync(file);
            const chapterData = [];
            
            const containerFile = zip.file('META-INF/container.xml');
            if (!containerFile) throw new Error('EPUB error: META-INF/container.xml not found.');
            const containerContent = await containerFile.async('text');
            const containerDoc = new DOMParser().parseFromString(containerContent, "text/xml");

            const rootfilePath = containerDoc.querySelector('rootfile')?.getAttribute('full-path');
            if (!rootfilePath) throw new Error('EPUB error: Rootfile path not found in container.xml.');
            const opfDir = rootfilePath.substring(0, rootfilePath.lastIndexOf('/') + 1);

            const opfFile = zip.file(rootfilePath);
            if (!opfFile) throw new Error(`EPUB error: OPF file not found at ${rootfilePath}`);
            const opfContent = await opfFile.async('text');
            const opfDoc = new DOMParser().parseFromString(opfContent, "text/xml");
            
            const ncxItem = opfDoc.querySelector('manifest item[media-type="application/x-dtbncx+xml"]');
            const ncxHref = ncxItem ? opfDir + ncxItem.getAttribute('href') : null;
            const navItem = Array.from(opfDoc.querySelectorAll('manifest item')).find(item => item.getAttribute('properties') === 'nav');
            const navHref = navItem ? opfDir + navItem.getAttribute('href') : null;
            const navMapTitles = new Map();

            if (ncxHref) {
              const ncxFile = zip.file(ncxHref);
              if (ncxFile) {
                const ncxContent = await ncxFile.async('text');
                const ncxDoc = new DOMParser().parseFromString(ncxContent, "text/xml");
                ncxDoc.querySelectorAll('navPoint').forEach(navPoint => {
                  const navLabel = navPoint.querySelector('navLabel text')?.textContent;
                  const contentSrc = navPoint.querySelector('content')?.getAttribute('src');
                  if (navLabel && contentSrc) {
                    navMapTitles.set(contentSrc.split('#')[0], navLabel.trim());
                  }
                });
              }
            }

            const extractTextWithFormatting = (node) => {
              let text = '';
              const blockElements = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'li', 'blockquote', 'tr', 'table', 'section', 'article'];
              if (node.nodeType === Node.TEXT_NODE) {
                text += node.textContent;
              } else if (node.nodeType === Node.ELEMENT_NODE) {
                const tagName = node.tagName.toLowerCase();
                if (tagName === 'br') text += '\n';
                for (const childNode of node.childNodes) {
                  text += extractTextWithFormatting(childNode);
                }
                if (blockElements.includes(tagName)) {
                  text = text.trimEnd() + '\n\n';
                }
              }
              return text;
            };

            const spine = opfDoc.querySelectorAll('spine itemref');
            for (const itemref of spine) {
              const idref = itemref.getAttribute('idref');
              const manifestItem = opfDoc.querySelector(`manifest item[id="${idref}"]`);
              const href = manifestItem?.getAttribute('href');
              if (href) {
                const contentPath = opfDir + href;
                if (contentPath === navHref || contentPath === ncxHref || href.toLowerCase().includes('toc.xhtml')) {
                  continue;
                }
                const mediaType = manifestItem.getAttribute('media-type');
                if (mediaType && (mediaType === 'application/xhtml+xml' || mediaType === 'text/html')) {
                  const contentFile = zip.file(contentPath);
                  if (contentFile) {
                    const htmlContent = await contentFile.async('text');
                    const parser = new DOMParser();
                    const doc = parser.parseFromString(htmlContent, "text/html");
                    doc.querySelectorAll('script, style').forEach(el => el.remove());
                    let chapterText = extractTextWithFormatting(doc.body);
                    let chapterTitle = navMapTitles.get(href.split('#')[0]) || doc.querySelector('h1, h2, h3, h4')?.textContent.trim() || `Chapter ${chapterData.length + 1}`;
                    if (chapterText.trim()) {
                      chapterData.push({ title: chapterTitle, text: chapterText });
                    }
                  }
                }
              }
            }
            if (chapterData.length === 0) {
              throw new Error('Could not extract readable text from EPUB file.');
            }
            return { chapters: chapterData };
          };

          const handleDownloadPDF = () => {
            if (!assembledTranslatedText || translatedChapters.length === 0) {
              setError('No translated text or chapter data to download as PDF.');
              return;
            }
            setDownloadingPdf(true);
            setError('');
            try {
              const { jsPDF } = window.jspdf;
              const doc = new jsPDF();
              doc.setFont('Helvetica', 'normal');
              const lineHeight = 7;
              const margin = 10;
              const maxWidth = doc.internal.pageSize.width - 2 * margin;
              let currentY = margin;

              translatedChapters.forEach((chapter, index) => {
                if (index > 0) {
                  doc.addPage();
                  currentY = margin;
                }

                if (chapter.title.trim()) {
                  doc.setFontSize(16);
                  doc.text(chapter.title, margin, currentY);
                  currentY += lineHeight * 2;
                }

                doc.setFontSize(12);
                const paragraphs = chapter.content.split(/\n\s*\n/).filter(p => p.trim() !== '');
                paragraphs.forEach((paragraph) => {
                  const textLines = doc.splitTextToSize(paragraph.trim(), maxWidth);
                  textLines.forEach(line => {
                    if (currentY + lineHeight > doc.internal.pageSize.height - margin) {
                      doc.addPage();
                      currentY = margin;
                    }
                    doc.text(line, margin, currentY);
                    currentY += lineHeight;
                  });
                  currentY += lineHeight * 0.5;
                });
              });

              doc.save(`translated_content_${targetLanguage.toLowerCase().replace(/\s/g, '-')}.pdf`);
            } catch (err) {
              setError(`Failed to generate PDF: ${err.message}`);
            } finally {
              setDownloadingPdf(false);
            }
          };

          const handleDownloadEPUB = async () => {
            if (!assembledTranslatedText || translatedChapters.length === 0) {
              setError('No translated text or chapter data to download as EPUB.');
              return;
            }
            setDownloadingEpub(true);
            setError('');

            try {
              const jepub = new jEpub();
              jepub.init({
                title: `Translated Content (${targetLanguage})`,
                author: 'Gemini Translator',
                publisher: 'Gemini Translator App',
                description: `Translated to ${targetLanguage}`,
                lang: targetLanguage.split(/[-_ ]/)[0].toLowerCase(),
                version: '3.0',
                uniqueIdentifier: `urn:uuid:${crypto.randomUUID()}`
              });

              translatedChapters.forEach((chapter) => {
                const paragraphs = chapter.content.split(/\n\s*\n/).filter(p => p.trim() !== '');
                const htmlBody = `
                  <!DOCTYPE html>
                  <html xmlns="http://www.w3.org/1999/xhtml">
                    <head>
                      <meta charset="UTF-8" />
                      <title>${chapter.title}</title>
                    </head>
                    <body>
                      <h1>${chapter.title}</h1>
                      ${paragraphs.map(p => `<p>${p.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\n/g, '<br/>')}</p>`).join('\n')}
                    </body>
                  </html>
                `;
                jepub.add(chapter.title, htmlBody);
              });

              const epubBlob = await jepub.generate();
              const url = URL.createObjectURL(epubBlob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `translated_content_${targetLanguage.toLowerCase().replace(/\s/g, '-')}.epub`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
              URL.revokeObjectURL(url);
            } catch (err) {
              setError(`Failed to generate EPUB: ${err.message}.`);
            } finally {
              setDownloadingEpub(false);
            }
          };

          return (
            <div className={`min-h-screen bg-gray-100 dark:bg-gray-900 font-sans text-gray-800 dark:text-gray-200 ${isDarkMode ? 'dark' : ''}`}>
              <div className="w-full min-h-screen bg-white dark:bg-gray-800 p-4 pt-8 sm:p-6 space-y-8">
                <div className="flex justify-between items-center">
                  <h1 className="text-4xl font-extrabold text-center text-indigo-600 dark:text-indigo-400 mb-2 tracking-tight">Gemini Translator</h1>
                  <button onClick={() => setIsDarkMode(!isDarkMode)} aria-label="Toggle dark mode" className="p-2">
                    {isDarkMode ? <Sun size={24} /> : <Moon size={24} />}
                  </button>
                </div>
                <p className="text-center text-sm text-gray-500 dark:text-gray-400 mb-6">Version: {version}</p>

                <div className="flex justify-center border-b border-gray-200 dark:border-gray-700">
                  <button
                    onClick={() => setActiveTab('text')}
                    className={`py-3 px-6 text-lg font-medium rounded-t-lg transition-colors duration-200 ${activeTab === 'text' ? 'bg-indigo-600 text-white shadow-md' : 'text-indigo-700 dark:text-indigo-300 hover:bg-indigo-100 dark:hover:bg-gray-700'}`}
                  >
                    <Clipboard className="inline-block mr-2" size={20} /> Text & File
                  </button>
                  <button
                    onClick={() => setActiveTab('url')}
                    className={`py-3 px-6 text-lg font-medium rounded-t-lg transition-colors duration-200 ${activeTab === 'url' ? 'bg-indigo-600 text-white shadow-md' : 'text-indigo-700 dark:text-indigo-300 hover:bg-indigo-100 dark:hover:bg-gray-700'}`}
                  >
                    <Link className="inline-block mr-2" size={20} /> URL (Info)
                  </button>
                </div>

                <div className="bg-gray-50 dark:bg-gray-800/50 p-6 rounded-xl shadow-inner">
                  {activeTab === 'text' && (
                    <div className="space-y-6">
                      <div>
                        <label htmlFor="fileUpload" className="block text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Upload File (TXT, PDF, EPUB, DOCX):</label>
                        <button
                          onClick={() => fileInputRef.current.click()}
                          className="w-full px-4 py-3 bg-purple-500 text-white font-semibold rounded-lg shadow-md hover:bg-purple-600 transition-all duration-200 flex items-center justify-center mb-4 disabled:opacity-50 disabled:cursor-not-allowed"
                          disabled={uploadingFile || isEbookTranslating || isTextTranslating}
                        >
                          {(uploadingFile || isEbookTranslating) ? <Loader2 className="animate-spin mr-2" size={20} /> : <Upload size={20} className="mr-2" />}
                          {uploadingFile ? 'Processing...' : (isEbookTranslating ? `Translating (${ebookTranslationProgress}%)` : 'Choose File & Translate')}
                        </button>
                        <input
                          type="file"
                          id="fileUpload"
                          ref={fileInputRef}
                          onChange={handleFileChange}
                          accept=".txt, .pdf, .epub, application/epub+zip, .docx"
                          className="hidden"
                          disabled={uploadingFile || isEbookTranslating || isTextTranslating}
                        />
                        {isEbookTranslating && (
                          <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mb-4">
                            <div className="bg-indigo-600 h-2.5 rounded-full" style={{ width: `${ebookTranslationProgress}%` }} />
                          </div>
                        )}
                        <label htmlFor="inputText" className="block text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Or Paste Text:</label>
                        <textarea
                          id="inputText"
                          className="w-full p-4 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 resize-y min-h-[450px] text-base"
                          placeholder="Paste your content here..."
                          value={inputText}
                          onChange={(e) => setInputText(e.target.value)}
                          disabled={isEbookTranslating || isTextTranslating}
                        />
                        <div className="flex flex-col gap-2 mt-2">
                          <button onClick={handlePasteInputText} className="w-full px-4 py-3 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition-all duration-200 flex items-center justify-center disabled:opacity-50 text-base" disabled={isEbookTranslating || isTextTranslating}>
                            <Clipboard size={18} className="mr-2" /> Paste Text
                          </button>
                          <button onClick={handleCopyInputText} className="w-full px-4 py-3 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 transition-all duration-200 flex items-center justify-center disabled:opacity-50 text-base" disabled={isEbookTranslating || isTextTranslating}>
                            <Copy size={18} className="mr-2" /> Copy Text
                          </button>
                          <button onClick={handleClearInput} className="w-full px-4 py-3 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition-all duration-200 flex items-center justify-center disabled:opacity-50 text-base" disabled={isEbookTranslating || isTextTranslating}>
                            <XCircle size={18} className="mr-2" /> Clear Input
                          </button>
                          <button onClick={handleSwapText} className="w-full px-4 py-3 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-200 font-semibold rounded-lg shadow-md hover:bg-gray-300 dark:hover:bg-gray-600 transition-all duration-200 flex items-center justify-center disabled:opacity-50 text-base" disabled={isEbookTranslating || isTextTranslating}>
                            <RefreshCcw size={18} className="mr-2" /> Swap Text
                          </button>
                        </div>
                      </div>
                      <div>
                        <label htmlFor="targetLanguage" className="block text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Translate to:</label>
                        <select
                          id="targetLanguage"
                          className="w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base disabled:opacity-50"
                          value={targetLanguage}
                          onChange={(e) => setTargetLanguage(e.target.value)}
                          disabled={isEbookTranslating || isTextTranslating}
                        >
                          {languages.map(lang => <option key={lang} value={lang}>{lang}</option>)}
                        </select>
                      </div>
                      <div className="flex flex-col items-center w-full mt-4">
                        <button
                          onClick={handleTranslateFromInputText}
                          className="w-full md:w-auto px-8 py-3 bg-indigo-600 text-white font-bold rounded-full shadow-lg hover:bg-indigo-700 focus:outline-none focus:ring-4 focus:ring-indigo-300 transition transform hover:scale-105 flex items-center justify-center text-lg disabled:opacity-50 disabled:cursor-not-allowed"
                          disabled={isTextTranslating || isEbookTranslating}
                        >
                          {isTextTranslating ? <Loader2 className="animate-spin mr-2" size={24} /> : <BookText className="mr-2" size={24} />}
                          {isTextTranslating ? `Translating... (${textTranslationProgress}%)` : 'Translate Pasted Text'}
                        </button>
                        {isTextTranslating && (
                          <div className="w-full md:w-1/2 bg-gray-200 dark:bg-gray-700 rounded-full h-2.5 mt-4">
                            <div className="bg-indigo-600 h-2.5 rounded-full" style={{ width: `${textTranslationProgress}%` }} />
                          </div>
                        )}
                      </div>
                    </div>
                  )}

                  {activeTab === 'url' && (
                    <div className="space-y-6">
                      <h2 className="text-xl font-bold text-gray-800 dark:text-gray-200">URL Content Information</h2>
                      <p className="text-gray-700 dark:text-gray-300 leading-relaxed">
                        <span className="font-semibold">Important Note:</span> This application runs entirely in your browser. For security reasons, it cannot directly fetch content from other websites (e.g., from a URL).<br /><br />
                        <span className="font-semibold">Workaround:</span> Please copy the text from the website or document you wish to translate and paste it into the "Text & File" tab.
                      </p>
                    </div>
                  )}
                </div>

                {assembledTranslatedText && (
                  <div className="space-y-6 pt-6 border-t border-gray-200 dark:border-gray-700">
                    <div>
                      <label htmlFor="assembledTranslatedText" className="block text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Translated Content ({targetLanguage}):</label>
                      <textarea
                        id="assembledTranslatedText"
                        readOnly
                        className="w-full p-4 border border-green-300 dark:border-green-700 bg-green-50 dark:bg-gray-900 rounded-lg shadow-inner focus:outline-none resize-y min-h-[200px] text-base"
                        value={assembledTranslatedText}
                      />
                    </div>
                    {copySuccess && <p className="text-sm text-green-700 dark:text-green-400 mt-2 text-center">{copySuccess}</p>}
                    <div className="flex flex-col sm:flex-row justify-center gap-4">
                      <button onClick={handleCopyToClipboard} className="w-full sm:w-auto px-6 py-3 bg-blue-500 text-white font-bold rounded-full shadow-lg hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 transition transform hover:scale-105 flex items-center justify-center text-lg">
                        <Copy className="mr-2" size={20} /> Copy
                      </button>
                      <button onClick={handleDownloadEPUB} className="w-full sm:w-auto px-6 py-3 bg-teal-500 text-white font-bold rounded-full shadow-lg hover:bg-teal-600 focus:outline-none focus:ring-4 focus:ring-teal-300 transition transform hover:scale-105 flex items-center justify-center text-lg" disabled={downloadingEpub || isEbookTranslating}>
                        {downloadingEpub ? <Loader2 className="animate-spin mr-2" size={20} /> : <Download className="mr-2" size={20} />}
                        {downloadingEpub ? 'Generating...' : 'Download EPUB'}
                      </button>
                      <button onClick={handleDownloadPDF} className="w-full sm:w-auto px-6 py-3 bg-red-500 text-white font-bold rounded-full shadow-lg hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300 transition transform hover:scale-105 flex items-center justify-center text-lg" disabled={downloadingPdf || isEbookTranslating}>
                        {downloadingPdf ? <Loader2 className="animate-spin mr-2" size={20} /> : <Download className="mr-2" size={20} />}
                        {downloadingPdf ? 'Generating...' : 'Download PDF'}
                      </button>
                    </div>
                  </div>
                )}

                <div className="space-y-4">
                  <label htmlFor="terminology" className="block text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Glossary:</label>
                  <textarea
                    id="terminology"
                    className="w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base resize-y min-h-[150px] disabled:opacity-50"
                    placeholder="Paste your glossary here"
                    value={terminology}
                    onChange={(e) => setTerminology(e.target.value)}
                    disabled={isEbookTranslating || isTextTranslating}
                  />
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-2 mt-2">
                    <button onClick={handlePasteTerminology} className="p-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition-all duration-200 flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      <Clipboard size={16} className="mr-1 sm:mr-2" /> <span className="hidden sm:inline">Paste</span>
                    </button>
                    <button onClick={handleCopyTerminology} className="p-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 transition-all duration-200 flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      <Copy size={16} className="mr-1 sm:mr-2" /> <span className="hidden sm:inline">Copy</span>
                    </button>
                    <button onClick={handleClearTerminology} className="p-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition-all duration-200 flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      <XCircle size={16} className="mr-1 sm:mr-2" /> <span className="hidden sm:inline">Clear</span>
                    </button>
                    <button onClick={handleGlossaryFileButtonClick} className="p-2 bg-purple-500 text-white font-semibold rounded-lg shadow-md hover:bg-purple-600 transition-all duration-200 flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating || uploadingFile}>
                      <Upload size={16} className="mr-1 sm:mr-2" /> <span className="hidden sm:inline">Upload</span>
                    </button>
                    <input type="file" ref={glossaryFileInputRef} onChange={handleGlossaryFileChange} className="hidden" accept=".txt,.md,.json,.csv,.xml,.html" />
                  </div>
                  <p className="text-sm text-gray-600 dark:text-gray-400">Enter terms to ensure they are translated correctly or kept in their original form.</p>
                </div>

                <div className="space-y-4 p-4 border border-gray-200 dark:border-gray-700 rounded-lg bg-gray-50 dark:bg-gray-800/50">
                  <h3 className="text-xl font-bold text-gray-800 dark:text-gray-200">Manage Glossaries</h3>
                  <div className="flex flex-col sm:flex-row gap-2 mb-4">
                    <input
                      type="text"
                      className="flex-grow p-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 disabled:opacity-50"
                      placeholder="New glossary name..."
                      value={newGlossaryName}
                      onChange={(e) => setNewGlossaryName(e.target.value)}
                      disabled={isEbookTranslating || isTextTranslating}
                    />
                    <button onClick={handleSaveGlossary} className="px-4 py-2 bg-purple-600 text-white font-semibold rounded-lg shadow-md hover:bg-purple-700 transition-all duration-200 disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      Save
                    </button>
                  </div>
                  <div className="flex flex-col sm:flex-row gap-2 mb-4">
                    <button onClick={handleSetDefaultGlossary} className="px-4 py-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition-all duration-200 disabled:opacity-50" disabled={!activeGlossaryId || isEbookTranslating || isTextTranslating}>
                      Set Default
                    </button>
                    <button onClick={handleClearDefaultGlossary} className="px-4 py-2 bg-orange-500 text-white font-semibold rounded-lg shadow-md hover:bg-orange-600 transition-all duration-200 disabled:opacity-50" disabled={!defaultGlossaryName || isEbookTranslating || isTextTranslating}>
                      Clear Default
                    </button>
                  </div>
                  {savedGlossaries.length > 0 && (
                    <div className="max-h-96 overflow-y-auto">
                      <ul className="space-y-2">
                        {[...savedGlossaries].sort((a, b) => {
                          if (a.name === activeGlossaryId) return -1;
                          if (b.name === activeGlossaryId) return 1;
                          return a.name.localeCompare(b.name);
                        }).map((glossary, index) => (
                          <li key={index} className={`flex flex-col sm:flex-row items-center justify-between p-4 bg-white dark:bg-gray-700 border border-gray-200 dark:border-gray-600 rounded-lg shadow-sm ${activeGlossaryId === glossary.name ? 'ring-2 ring-indigo-500' : ''}`}>
                            <span className={`font-medium text-lg ${activeGlossaryId === glossary.name ? 'text-indigo-600 dark:text-indigo-400' : 'text-gray-800 dark:text-gray-200'} mb-3 sm:mb-0 text-center sm:text-left w-full sm:w-auto`}>
                              {glossary.name}
                              {defaultGlossaryName === glossary.name && <span className="text-sm text-indigo-500 dark:text-indigo-400 ml-2">(Default)</span>}
                            </span>
                            <div className="flex items-center w-full sm:w-auto justify-center gap-2">
                              <button onClick={() => handleLoadGlossary(glossary)} className="px-4 py-2 text-base bg-blue-500 text-white rounded-lg shadow-md hover:bg-blue-600 transition-all duration-200 disabled:opacity-50 flex-1" disabled={isEbookTranslating || isTextTranslating}>
                                Load
                              </button>
                              {activeGlossaryId === glossary.name && (
                                <button onClick={() => handleUpdateSpecificGlossary(glossary.name)} className="px-4 py-2 text-base bg-green-500 text-white rounded-lg shadow-md hover:bg-green-600 transition-all duration-200 disabled:opacity-50 flex-1" disabled={isEbookTranslating || isTextTranslating}>
                                  Update
                                </button>
                              )}
                              <button onClick={() => handleDeleteGlossary(glossary.name)} className="px-4 py-2 text-base bg-red-500 text-white rounded-lg shadow-md hover:bg-red-600 transition-all duration-200 disabled:opacity-50 flex-1" disabled={isEbookTranslating || isTextTranslating}>
                                Delete
                              </button>
                            </div>
                          </li>
                        ))}
                      </ul>
                    </div>
                  )}
                </div>

                <div className="space-y-4">
                  <label htmlFor="geminiModel" className="block text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Gemini Model:</label>
                  <select
                    id="geminiModel"
                    className="w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base disabled:opacity-50"
                    value={geminiModel}
                    onChange={(e) => {
                      const newModel = e.target.value;
                      setGeminiModel(newModel);
                      localStorage.setItem('geminiModel', newModel);
                      setCopySuccess(`Model switched to ${newModel}`);
                      setTimeout(() => setCopySuccess(''), 3000);
                    }}
                    disabled={isEbookTranslating || isTextTranslating}
                  >
                    <option value="gemini-3-flash">Gemini 3 Flash</option>
                    <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                    <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                    <option value="gemini-2.5-flash-lite">Gemini 2.5 Flash-Lite</option>
                    <option value="gemini-2.5-flash">Gemini 2.5 Flash</option>
                  </select>
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">Select the Gemini model for translations. Newer models might offer better quality.</p>
                </div>

                <div className="space-y-4">
                  <label htmlFor="apiKeyInput" className="block text-lg font-semibold text-gray-700 dark:text-gray-300 mb-2">Your Gemini API Key:</label>
                  <div className="relative flex items-center">
                    <input
                      id="apiKeyInput"
                      type={showApiKey ? 'text' : 'password'}
                      className="w-full p-3 pr-10 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg shadow-sm focus:ring-indigo-500 focus:border-indigo-500 transition duration-200 text-base disabled:opacity-50"
                      placeholder="Required for translation..."
                      value={apiKeyInput}
                      onChange={(e) => setApiKeyInput(e.target.value)}
                      disabled={isEbookTranslating || isTextTranslating}
                    />
                    <button type="button" onClick={() => setShowApiKey(!showApiKey)} className="absolute right-3 p-1 rounded-full text-gray-500 hover:text-gray-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      {showApiKey ? <EyeOff size={20} /> : <Eye size={20} />}
                    </button>
                  </div>
                  <div className="grid grid-cols-2 sm:grid-cols-4 gap-2 mt-2">
                    <button onClick={handleSaveApiKey} className="p-2 bg-green-500 text-white font-semibold rounded-lg shadow-md hover:bg-green-600 transition-colors flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      Save
                    </button>
                    <button onClick={handlePasteApiKey} className="p-2 bg-blue-500 text-white font-semibold rounded-lg shadow-md hover:bg-blue-600 transition-colors flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      Paste
                    </button>
                    <button onClick={handleCopyApiKey} className="p-2 bg-gray-600 text-white font-semibold rounded-lg shadow-md hover:bg-gray-700 transition-colors flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      Copy
                    </button>
                    <button onClick={handleClearApiKey} className="p-2 bg-red-500 text-white font-semibold rounded-lg shadow-md hover:bg-red-600 transition-colors flex items-center justify-center disabled:opacity-50" disabled={isEbookTranslating || isTextTranslating}>
                      Clear
                    </button>
                  </div>
                  <p className="text-sm text-gray-600 dark:text-gray-400 mt-2">{apiKeyStatus}</p>
                </div>

                {error && (
                  <div className="bg-red-100 border-l-4 border-red-500 text-red-700 p-4 rounded-md shadow-md flex items-center justify-between">
                    <p className="font-medium">{error}</p>
                    <XCircle className="cursor-pointer" size={20} onClick={() => setError('')} />
                  </div>
                )}

                {isEbookTranslating && <p className="text-center">{ebookTranslationStatus}</p>}

                {showModal && (
                  <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 max-w-sm w-full space-y-4">
                      <p className="text-lg font-semibold text-gray-800 dark:text-gray-200 text-center">{modalMessage}</p>
                      <div className="flex justify-center gap-4 mt-4">
                        <button onClick={handleModalConfirm} className="px-6 py-2 bg-indigo-600 text-white rounded-md hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-colors">
                          Confirm
                        </button>
                        <button onClick={handleModalCancel} className="px-6 py-2 bg-gray-300 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-md hover:bg-gray-400 dark:hover:bg-gray-500 focus:outline-none focus:ring-2 focus:ring-gray-500 transition-colors">
                          Cancel
                        </button>
                      </div>
                    </div>
                  </div>
                )}
              </div>
            </div>
          );
        }

        ReactDOM.createRoot(document.getElementById('root')).render(<App />);
    </script>
</body>
</html>

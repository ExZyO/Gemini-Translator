<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gemini Translator</title>
  <meta name="description"
    content="AI-powered translation with Gemini, DeepL, and LibreTranslate. Supports PDF, EPUB, TXT files with glossary management.">
  <link rel="manifest" href="./manifest.json">
  <link rel="apple-touch-icon" href="https://placehold.co/192x192/8b5cf6/ffffff?text=GT" sizes="192x192">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Gemini Translator">
  <script src="https://cdn.tailwindcss.com"></script>
  <script>tailwind.config = { darkMode: 'class' }</script>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jepub/dist/jepub.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ejs/3.1.9/ejs.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/docx@8.5.0/build/index.umd.min.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      transition: background-color .3s, color .3s
    }

    @keyframes toastIn {
      from {
        transform: translateX(100%);
        opacity: 0
      }

      to {
        transform: translateX(0);
        opacity: 1
      }
    }

    @keyframes toastOut {
      from {
        transform: translateX(0);
        opacity: 1
      }

      to {
        transform: translateX(100%);
        opacity: 0
      }
    }

    .toast-enter {
      animation: toastIn .3s ease-out forwards
    }

    .toast-exit {
      animation: toastOut .3s ease-in forwards
    }

    .drop-zone-active {
      border: 3px dashed #6366f1 !important;
      background: rgba(99, 102, 241, .08) !important
    }

    .dark .drop-zone-active {
      background: rgba(99, 102, 241, .15) !important
    }

    *:focus-visible {
      outline: 2px solid #6366f1;
      outline-offset: 2px;
      border-radius: 4px
    }

    .collapsible {
      max-height: 0;
      overflow: hidden;
      transition: max-height .3s ease-out
    }

    .collapsible.open {
      max-height: 5000px
    }
  </style>
</head>

<body>
  <div id="root"></div>
  <script type="module">
    import React, { useState, useEffect, useRef, useCallback } from 'https://esm.sh/react@18.2.0';
    import ReactDOM from 'https://esm.sh/react-dom@18.2.0/client';
    import { Download, Clipboard, Link, BookText, FileText, XCircle, Copy, Loader2, Eye, EyeOff, RefreshCcw, Save, Upload, Sun, Moon, Columns2, Rows2, History, ChevronDown, ChevronUp, Zap, X, CheckCircle2, AlertCircle, Info, Search, Trash2, RotateCcw, Square, FileDown, Settings, Globe } from 'https://esm.sh/lucide-react@0.372.0';
    const h = React.createElement;

    // ═══════════════════════════════════════
    // CONSTANTS
    // ═══════════════════════════════════════
    const VERSION = '4.1.0';
    const MAX_PAYLOAD = 60000;
    const PROMPT_OVERHEAD = 800;
    const MAX_HISTORY = 20;
    const DEFAULT_CONCURRENCY = 3;
    const LANGUAGES = ['Auto-detect', 'English', 'Spanish', 'French', 'German', 'Italian', 'Portuguese', 'Chinese (Simplified)', 'Chinese (Traditional)', 'Japanese', 'Korean', 'Russian', 'Arabic', 'Hindi', 'Bengali', 'Urdu', 'Vietnamese', 'Turkish', 'Polish', 'Dutch', 'Swedish', 'Norwegian', 'Danish', 'Finnish', 'Greek', 'Hebrew', 'Thai', 'Indonesian', 'Malay', 'Filipino', 'Romanian', 'Hungarian', 'Czech', 'Slovak', 'Bulgarian', 'Serbian', 'Croatian', 'Ukrainian', 'Lithuanian', 'Latvian', 'Estonian', 'Slovenian', 'Catalan', 'Basque', 'Galician'];
    const TARGET_LANGUAGES = LANGUAGES.filter(l => l !== 'Auto-detect');

    const DEEPL_LANG_MAP = { 'English': 'EN', 'Spanish': 'ES', 'French': 'FR', 'German': 'DE', 'Italian': 'IT', 'Portuguese': 'PT', 'Chinese (Simplified)': 'ZH', 'Chinese (Traditional)': 'ZH', 'Japanese': 'JA', 'Korean': 'KO', 'Russian': 'RU', 'Arabic': 'AR', 'Hindi': 'HI', 'Vietnamese': 'VI', 'Turkish': 'TR', 'Polish': 'PL', 'Dutch': 'NL', 'Swedish': 'SV', 'Norwegian': 'NB', 'Danish': 'DA', 'Finnish': 'FI', 'Greek': 'EL', 'Hebrew': 'HE', 'Indonesian': 'ID', 'Romanian': 'RO', 'Hungarian': 'HU', 'Czech': 'CS', 'Slovak': 'SK', 'Bulgarian': 'BG', 'Serbian': 'SR', 'Croatian': 'HR', 'Ukrainian': 'UK', 'Lithuanian': 'LT', 'Latvian': 'LV', 'Estonian': 'ET', 'Slovenian': 'SL' };
    const LIBRE_LANG_MAP = { 'English': 'en', 'Spanish': 'es', 'French': 'fr', 'German': 'de', 'Italian': 'it', 'Portuguese': 'pt', 'Chinese (Simplified)': 'zh', 'Chinese (Traditional)': 'zt', 'Japanese': 'ja', 'Korean': 'ko', 'Russian': 'ru', 'Arabic': 'ar', 'Hindi': 'hi', 'Vietnamese': 'vi', 'Turkish': 'tr', 'Polish': 'pl', 'Dutch': 'nl', 'Swedish': 'sv', 'Norwegian': 'nb', 'Danish': 'da', 'Finnish': 'fi', 'Greek': 'el', 'Hebrew': 'he', 'Indonesian': 'id', 'Filipino': 'tl', 'Romanian': 'ro', 'Hungarian': 'hu', 'Czech': 'cs', 'Slovak': 'sk', 'Bulgarian': 'bg', 'Serbian': 'sr', 'Croatian': 'hr', 'Ukrainian': 'uk' };

    // ═══════════════════════════════════════
    // UTILITY FUNCTIONS
    // ═══════════════════════════════════════
    const fetchRetry = async (url, opts, retries = 5) => {
      let delay = 2000;
      for (let i = 0; i < retries; i++) {
        try {
          const r = await fetch(url, opts);
          if ((r.status === 429 || r.status >= 500) && i < retries - 1) {
            console.warn(`API Error ${r.status}. Retrying in ${delay}ms... (${i + 1}/${retries})`);
            await new Promise(t => setTimeout(t, delay));
            delay *= 2;
            continue;
          }
          return r;
        } catch (e) {
          if (i === retries - 1) throw e;
          console.warn(`Network Error. Retrying in ${delay}ms... (${i + 1}/${retries})`);
          await new Promise(t => setTimeout(t, delay));
          delay *= 2;
        }
      }
    };
    const wordCount = t => t.trim() ? t.trim().split(/\s+/).length : 0;
    const charCount = t => t.length;
    const genId = () => Date.now().toString(36) + Math.random().toString(36).slice(2);

    // Parallel batch executor: runs tasks in batches of `concurrency`
    const batchParallel = async (items, fn, concurrency = 3) => {
      const results = new Array(items.length);
      for (let i = 0; i < items.length; i += concurrency) {
        const batch = items.slice(i, i + concurrency);
        const batchResults = await Promise.allSettled(batch.map((item, idx) => fn(item, i + idx)));
        batchResults.forEach((r, idx) => { results[i + idx] = r.status === 'fulfilled' ? r.value : { error: r.reason?.message || 'Unknown error' }; });
      }
      return results;
    };
    const cleanText = t => { let c = t.replace(/\r\n|\r/g, '\n'); c = c.replace(/[ \t]{2,}/g, ' '); c = c.replace(/(\n\s*){2,}/g, '\n\n'); return c.trim() };
    const copyText = async t => { await navigator.clipboard.writeText(t) };

    // Session State utilities
    const generateJobId = (text, isFile = false) => {
      // Simple hash to identify the document being translated
      let hash = 0; const s = isFile ? text : text.substring(0, 1000);
      for (let i = 0; i < s.length; i++) { hash = ((hash << 5) - hash) + s.charCodeAt(i); hash |= 0; }
      return `job_${Math.abs(hash)}`;
    };

    const splitChunks = (text, glossaryLen = 0) => {
      let max = MAX_PAYLOAD - PROMPT_OVERHEAD - glossaryLen;
      if (max <= 0) max = 500;
      const chunks = []; let rem = text;
      while (rem.length > 0) {
        if (rem.length <= max) { chunks.push(rem); break }
        let sp = max;
        let idx = rem.lastIndexOf('\n\n', max);
        if (idx !== -1 && idx > max * 0.7) sp = idx + 2;
        else {
          idx = rem.lastIndexOf('\n', max); if (idx !== -1 && idx > max * 0.7) sp = idx + 1;
          else { idx = Math.max(rem.lastIndexOf('.', max), rem.lastIndexOf('?', max), rem.lastIndexOf('!', max)); if (idx !== -1 && idx > max * 0.7) sp = idx + 1 }
        }
        if (sp <= 0) sp = max;
        chunks.push(rem.substring(0, sp)); rem = rem.substring(sp).trimStart();
      }
      return chunks;
    };

    // ═══════════════════════════════════════
    // TRANSLATION PROVIDERS
    // ═══════════════════════════════════════
    const buildPrompt = (text, srcLang, tgtLang, glossary, instructions, context) => {
      let p = `Please translate the following text${srcLang && srcLang !== 'Auto-detect' ? ' from ' + srcLang : ''} into ${tgtLang}. IMPORTANT: Preserve all original paragraph breaks and line breaks exactly.\n\n${text}\n\n`;
      if (glossary.trim()) p = `Use this Terminology Guide for specific terms.\n---\nTerminology Guide:\n${glossary.trim()}\n---\n\n` + p;
      if (instructions.trim()) p = `Additional instructions: ${instructions.trim()}\n\n` + p;

      if (context !== undefined) {
        p = `TRANSLATION CONTEXT (from previously translated sections):\n${context || 'None yet.'}\n\nUse the above context to maintain consistency in character names, tone, terminology, and narrative flow. Do NOT repeat the context.\n\n` + p;
        p += `Provide ONLY the ${tgtLang} translation, followed EXACTLY by the delimiter "\n---CONTEXT_UPDATE---\n", followed by a brief updated context summary (max 100 words) capturing key characters, plot points, and tone including this new section.`;
      } else {
        p += `Provide ONLY the ${tgtLang} translation. No commentary.`;
      }
      return p;
    };

    const translateGemini = async (text, { apiKey, model, srcLang, tgtLang, glossary, instructions, signal, context }) => {
      if (!apiKey) throw new Error('Gemini API key required.');
      const prompt = buildPrompt(text, srcLang, tgtLang, glossary, instructions, context);
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;
      const r = await fetchRetry(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ role: 'user', parts: [{ text: prompt }] }] }), signal });
      if (!r.ok) { const b = await r.text().catch(() => ''); throw new Error(`Gemini API error ${r.status}: ${b.substring(0, 200)}`); }
      const j = await r.json();
      const t = j?.candidates?.[0]?.content?.parts?.[0]?.text;
      if (!t) throw new Error('Unexpected Gemini response format.');
      if (context !== undefined) {
        const parts = t.split(/\n*---CONTEXT_UPDATE---\n*/i);
        return { text: parts[0].trim(), newContext: parts.length > 1 ? parts[1].trim() : context };
      }
      return t;
    };

    const streamGemini = async (text, { apiKey, model, srcLang, tgtLang, glossary, instructions, signal, onChunk, context }) => {
      if (!apiKey) throw new Error('Gemini API key required.');
      const prompt = buildPrompt(text, srcLang, tgtLang, glossary, instructions, context);
      const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?alt=sse&key=${apiKey}`;
      const r = await fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ contents: [{ role: 'user', parts: [{ text: prompt }] }] }), signal });
      if (!r.ok) { const b = await r.text().catch(() => ''); throw new Error(`Gemini stream error ${r.status}: ${b.substring(0, 200)}`); }
      const reader = r.body.getReader(); const dec = new TextDecoder(); let buf = '';
      let isContextContext = false;
      let finalContext = '';
      let slidingWindow = '';
      while (true) {
        const { done, value } = await reader.read(); if (done) break;
        buf += dec.decode(value, { stream: true });
        const lines = buf.split('\n'); buf = lines.pop() || '';
        for (const line of lines) {
          if (line.startsWith('data: ')) {
            const d = line.slice(6).trim();
            if (d === '[DONE]') {
              if (slidingWindow && !isContextContext) onChunk(slidingWindow);
              return { text: '', newContext: finalContext.trim() || context || '' };
            }
            try {
              const j = JSON.parse(d); const t = j?.candidates?.[0]?.content?.parts?.[0]?.text;
              if (t) {
                if (context !== undefined) {
                  if (isContextContext) {
                    finalContext += t;
                  } else {
                    slidingWindow += t;
                    const splitMatch = slidingWindow.match(/\n*---CONTEXT_UPDATE---\n*/i);
                    if (splitMatch) {
                      const idx = splitMatch.index;
                      const textPart = slidingWindow.substring(0, idx);
                      if (textPart) onChunk(textPart);
                      finalContext += slidingWindow.substring(idx + splitMatch[0].length);
                      isContextContext = true;
                      slidingWindow = '';
                    } else {
                      if (slidingWindow.length > 40) {
                        const safeToEmit = slidingWindow.substring(0, slidingWindow.length - 40);
                        onChunk(safeToEmit);
                        slidingWindow = slidingWindow.substring(slidingWindow.length - 40);
                      }
                    }
                  }
                } else {
                  onChunk(t);
                }
              }
            } catch (e) { }
          }
        }
      }
      if (slidingWindow && !isContextContext) onChunk(slidingWindow);
      return { text: '', newContext: finalContext.trim() || context || '' };
    };

    const translateDeepL = async (text, { apiKey, srcLang, tgtLang, signal }) => {
      if (!apiKey) throw new Error('DeepL API key required.');
      const tgt = DEEPL_LANG_MAP[tgtLang]; if (!tgt) throw new Error(`DeepL doesn't support ${tgtLang}.`);
      const src = srcLang && srcLang !== 'Auto-detect' ? DEEPL_LANG_MAP[srcLang] : undefined;
      const params = new URLSearchParams({ text, target_lang: tgt });
      if (src) params.append('source_lang', src);
      const base = apiKey.endsWith(':fx') ? 'https://api-free.deepl.com' : 'https://api.deepl.com';
      const r = await fetchRetry(`${base}/v2/translate`, { method: 'POST', headers: { 'Authorization': `DeepL-Auth-Key ${apiKey}`, 'Content-Type': 'application/x-www-form-urlencoded' }, body: params.toString(), signal });
      if (!r.ok) { const b = await r.text().catch(() => ''); throw new Error(`DeepL error ${r.status}: ${b.substring(0, 200)}`); }
      const j = await r.json(); return j.translations?.[0]?.text || '';
    };

    const translateLibre = async (text, { srcLang, tgtLang, signal, libreUrl }) => {
      const tgt = LIBRE_LANG_MAP[tgtLang]; if (!tgt) throw new Error(`LibreTranslate doesn't support ${tgtLang}.`);
      const src = srcLang && srcLang !== 'Auto-detect' ? (LIBRE_LANG_MAP[srcLang] || 'auto') : 'auto';
      const url = libreUrl || 'https://libretranslate.com';
      const r = await fetchRetry(`${url}/translate`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ q: text, source: src, target: tgt, format: 'text' }), signal });
      if (!r.ok) { const b = await r.text().catch(() => ''); throw new Error(`LibreTranslate error ${r.status}: ${b.substring(0, 200)}`); }
      const j = await r.json(); return j.translatedText || '';
    };

    const translateChunk = async (text, opts) => {
      switch (opts.provider) {
        case 'deepl': return translateDeepL(text, opts);
        case 'libre': return translateLibre(text, opts);
        default: return translateGemini(text, { ...opts, context: opts.context });
      }
    };

    const fetchGeminiModels = async (apiKey) => {
      const r = await fetch(`https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}&pageSize=100`);
      if (!r.ok) throw new Error('Failed to fetch models');
      const j = await r.json();
      return (j.models || []).filter(m => m.supportedGenerationMethods?.includes('generateContent')).map(m => ({ id: m.name.replace('models/', ''), name: m.displayName || m.name.replace('models/', '') }));
    };

    // ═══════════════════════════════════════
    // ERROR BOUNDARY
    // ═══════════════════════════════════════
    class ErrorBoundary extends React.Component {
      constructor(p) { super(p); this.state = { hasError: false, error: null } }
      static getDerivedStateFromError(e) { return { hasError: true, error: e } }
      render() { if (this.state.hasError) return h('div', { className: 'min-h-screen flex items-center justify-center bg-red-50 dark:bg-gray-900 p-8' }, h('div', { className: 'max-w-lg text-center' }, h('h1', { className: 'text-2xl font-bold text-red-600 mb-4' }, 'Something went wrong'), h('p', { className: 'text-gray-700 dark:text-gray-300 mb-4' }, this.state.error?.message), h('button', { onClick: () => this.setState({ hasError: false, error: null }), className: 'px-6 py-2 bg-indigo-600 text-white rounded-lg' }, 'Try Again'))); return this.props.children }
    }

    // ═══════════════════════════════════════
    // MAIN APP
    // ═══════════════════════════════════════
    function App() {
      // --- Core State ---
      const [inputText, setInputText] = useState('');
      const [assembledText, setAssembledText] = useState('');
      const [terminology, setTerminology] = useState('');
      const [customInstructions, setCustomInstructions] = useState('');
      const [activeTab, setActiveTab] = useState('text');
      const [error, setError] = useState('');

      // --- Translation State ---
      const [isTranslating, setIsTranslating] = useState(false);
      const [progress, setProgress] = useState(0);
      const [progressLabel, setProgressLabel] = useState('');
      const [translatedChapters, setTranslatedChapters] = useState([]);

      // --- Provider State ---
      const [provider, setProvider] = useState(() => localStorage.getItem('translationProvider') || 'gemini');
      const [geminiKey, setGeminiKey] = useState(() => localStorage.getItem('geminiApiKey') || '');
      const [geminiKeyInput, setGeminiKeyInput] = useState(() => localStorage.getItem('geminiApiKey') || '');
      const [deeplKey, setDeeplKey] = useState(() => localStorage.getItem('deeplApiKey') || '');
      const [deeplKeyInput, setDeeplKeyInput] = useState(() => localStorage.getItem('deeplApiKey') || '');
      const [libreUrl, setLibreUrl] = useState(() => localStorage.getItem('libreUrl') || 'https://libretranslate.com');
      const [geminiModel, setGeminiModel] = useState(() => localStorage.getItem('geminiModel') || 'gemini-2.5-flash');
      const [availableModels, setAvailableModels] = useState([]);
      const [customModel, setCustomModel] = useState('');
      const [useCustomModel, setUseCustomModel] = useState(false);
      const [showGeminiKey, setShowGeminiKey] = useState(false);
      const [showDeeplKey, setShowDeeplKey] = useState(false);
      const [enableStreaming, setEnableStreaming] = useState(() => localStorage.getItem('enableStreaming') === 'true');
      const [concurrency, setConcurrency] = useState(() => parseInt(localStorage.getItem('concurrency')) || DEFAULT_CONCURRENCY);
      const [contextAware, setContextAware] = useState(() => localStorage.getItem('contextAware') !== 'false');

      // --- Language State ---
      const [srcLang, setSrcLang] = useState('Auto-detect');
      const [tgtLang, setTgtLang] = useState('English');

      // --- Glossary State ---
      const [savedGlossaries, setSavedGlossaries] = useState([]);
      const [newGlossaryName, setNewGlossaryName] = useState('');
      const [activeGlossaryId, setActiveGlossaryId] = useState(null);
      const [defaultGlossaryName, setDefaultGlossaryName] = useState(() => localStorage.getItem('defaultGlossaryName') || null);

      // --- Session/Resume State ---
      const [activeSession, setActiveSession] = useState(null);
      const [currentFileHash, setCurrentFileHash] = useState('');

      // --- UI State ---
      const [darkMode, setDarkMode] = useState(() => { const s = localStorage.getItem('darkMode'); return s !== null ? s === 'true' : window.matchMedia('(prefers-color-scheme:dark)').matches });
      const [toasts, setToasts] = useState([]);
      const [sideBySide, setSideBySide] = useState(false);
      const [showModal, setShowModal] = useState(false);
      const [modalMessage, setModalMessage] = useState('');
      const [modalCallback, setModalCallback] = useState(null);
      const [history, setHistory] = useState([]);
      const [showHistory, setShowHistory] = useState(false);
      const [showSettings, setShowSettings] = useState(true);
      const [showGlossaryManager, setShowGlossaryManager] = useState(true);
      const [uploadingFile, setUploadingFile] = useState(false);
      const [downloadingPdf, setDownloadingPdf] = useState(false);
      const [downloadingEpub, setDownloadingEpub] = useState(false);
      const [downloadingDocx, setDownloadingDocx] = useState(false);
      const [isDragOver, setIsDragOver] = useState(false);

      // --- Refs ---
      const fileInputRef = useRef(null);
      const glossaryFileRef = useRef(null);
      const abortRef = useRef(null);

      // --- Toast Helper ---
      const toast = (msg, type = 'success') => { const id = genId(); setToasts(p => [...p, { id, msg, type }]); setTimeout(() => setToasts(p => p.filter(t => t.id !== id)), 3500) };

      // --- Effects ---
      useEffect(() => { document.documentElement.classList.toggle('dark', darkMode); localStorage.setItem('darkMode', String(darkMode)) }, [darkMode]);
      useEffect(() => { localStorage.setItem('enableStreaming', String(enableStreaming)) }, [enableStreaming]);
      useEffect(() => { localStorage.setItem('translationProvider', provider) }, [provider]);
      useEffect(() => { localStorage.setItem('concurrency', String(concurrency)) }, [concurrency]);
      useEffect(() => { localStorage.setItem('contextAware', String(contextAware)) }, [contextAware]);

      useEffect(() => {
        if (!inputText && !currentFileHash) { setActiveSession(null); return; }
        const id = inputText ? generateJobId(inputText) : currentFileHash;
        const saved = localStorage.getItem(id);
        setActiveSession(saved ? JSON.parse(saved) : null);
      }, [inputText, currentFileHash, provider, contextAware]);

      useEffect(() => {
        const g = JSON.parse(localStorage.getItem('savedGlossaries') || '[]'); setSavedGlossaries(g);
        const h = JSON.parse(localStorage.getItem('translationHistory') || '[]'); setHistory(h);
        const dg = localStorage.getItem('defaultGlossaryName');
        if (dg) { setDefaultGlossaryName(dg); const found = g.find(x => x.name === dg); if (found) { setTerminology(found.content); setActiveGlossaryId(found.name) } else { localStorage.removeItem('defaultGlossaryName'); setDefaultGlossaryName(null) } }
        if (typeof window.pdfjsLib !== 'undefined') window.pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';
      }, []);

      useEffect(() => { if (geminiKey) fetchGeminiModels(geminiKey).then(m => { setAvailableModels(m); if (m.length && !m.find(x => x.id === geminiModel) && !useCustomModel && m[0]) setGeminiModel(m[0].id) }).catch(() => { }) }, [geminiKey]);

      // Keyboard shortcuts
      useEffect(() => {
        const handler = e => { if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') { e.preventDefault(); if (!isTranslating) handleTranslateText() } if ((e.ctrlKey || e.metaKey) && e.shiftKey && e.key === 'C') { e.preventDefault(); if (assembledText) copyText(assembledText).then(() => toast('Copied!')).catch(() => { }) } };
        window.addEventListener('keydown', handler); return () => window.removeEventListener('keydown', handler);
      });

      // --- API Key Handlers ---
      const saveGeminiKey = () => { if (!geminiKeyInput.trim()) return setError('API key cannot be empty.'); localStorage.setItem('geminiApiKey', geminiKeyInput.trim()); setGeminiKey(geminiKeyInput.trim()); toast('Gemini API key saved!'); setError('') };
      const clearGeminiKey = () => { localStorage.removeItem('geminiApiKey'); setGeminiKey(''); setGeminiKeyInput(''); setAvailableModels([]); toast('Gemini API key cleared.', 'info') };
      const saveDeeplKey = () => { if (!deeplKeyInput.trim()) return setError('API key cannot be empty.'); localStorage.setItem('deeplApiKey', deeplKeyInput.trim()); setDeeplKey(deeplKeyInput.trim()); toast('DeepL API key saved!'); setError('') };
      const clearDeeplKey = () => { localStorage.removeItem('deeplApiKey'); setDeeplKey(''); setDeeplKeyInput(''); toast('DeepL API key cleared.', 'info') };
      const saveLibreUrl = () => { localStorage.setItem('libreUrl', libreUrl); toast('LibreTranslate URL saved!') };

      // --- Profile/Glossary Handlers ---
      const handleSaveGlossary = () => { if (!newGlossaryName.trim()) return setError('Enter a profile name.'); if (!terminology.trim() && !customInstructions.trim()) return setError('Profile content is empty.'); const existing = savedGlossaries.findIndex(g => g.name === newGlossaryName.trim()); if (existing > -1) { confirmAction(`Overwrite "${newGlossaryName.trim()}"?`, () => { const u = [...savedGlossaries]; u[existing] = { name: newGlossaryName.trim(), content: terminology, instructions: customInstructions }; setSavedGlossaries(u); localStorage.setItem('savedGlossaries', JSON.stringify(u)); setNewGlossaryName(''); setActiveGlossaryId(newGlossaryName.trim()); toast('Profile updated!') }) } else { const u = [...savedGlossaries, { name: newGlossaryName.trim(), content: terminology, instructions: customInstructions }]; setSavedGlossaries(u); localStorage.setItem('savedGlossaries', JSON.stringify(u)); setNewGlossaryName(''); setActiveGlossaryId(newGlossaryName.trim()); setError(''); toast('Profile saved!') } };
      const handleLoadGlossary = g => { setTerminology(g.content || ''); setCustomInstructions(g.instructions || ''); setActiveGlossaryId(g.name); toast(`Loaded "${g.name}"`) };
      const handleDeleteGlossary = n => { confirmAction(`Delete "${n}"?`, () => { const u = savedGlossaries.filter(g => g.name !== n); setSavedGlossaries(u); localStorage.setItem('savedGlossaries', JSON.stringify(u)); if (activeGlossaryId === n) { setTerminology(''); setCustomInstructions(''); setActiveGlossaryId(null) } if (defaultGlossaryName === n) { localStorage.removeItem('defaultGlossaryName'); setDefaultGlossaryName(null) } toast('Profile deleted.', 'info') }) };
      const handleUpdateGlossary = n => { const i = savedGlossaries.findIndex(g => g.name === n); if (i > -1) { const u = [...savedGlossaries]; u[i] = { name: n, content: terminology, instructions: customInstructions }; setSavedGlossaries(u); localStorage.setItem('savedGlossaries', JSON.stringify(u)); toast(`"${n}" updated!`) } };
      const setDefaultGloss = () => { if (!activeGlossaryId) return setError('Load a profile first.'); localStorage.setItem('defaultGlossaryName', activeGlossaryId); setDefaultGlossaryName(activeGlossaryId); toast(`"${activeGlossaryId}" set as default!`) };
      const clearDefaultGloss = () => { confirmAction('Clear default profile?', () => { localStorage.removeItem('defaultGlossaryName'); setDefaultGlossaryName(null); toast('Default cleared.', 'info') }) };
      const exportGlossaries = () => { const blob = new Blob([JSON.stringify(savedGlossaries, null, 2)], { type: 'application/json' }); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'glossaries_backup.json'; a.click(); URL.revokeObjectURL(a.href); toast('Glossaries exported!') };
      const importGlossaries = async e => { const f = e.target.files[0]; if (!f) return; try { const txt = await f.text(); const data = JSON.parse(txt); if (!Array.isArray(data)) throw new Error('Invalid format'); const merged = [...savedGlossaries]; data.forEach(g => { if (g.name && g.content && !merged.find(x => x.name === g.name)) merged.push(g) }); setSavedGlossaries(merged); localStorage.setItem('savedGlossaries', JSON.stringify(merged)); toast(`Imported ${data.length} glossaries!`) } catch (err) { setError('Invalid glossary file: ' + err.message) } e.target.value = '' };
      const handleGlossaryFile = async e => { const f = e.target.files[0]; if (!f) return; try { const txt = await f.text(); setTerminology(txt); setNewGlossaryName(f.name.replace(/\.[^.]+$/, '')); toast(`Glossary loaded from ${f.name}`) } catch (err) { setError('Failed to read file: ' + err.message) } e.target.value = '' };

      // --- Modal ---
      const confirmAction = (msg, cb) => { setModalMessage(msg); setModalCallback(() => () => { cb(); setShowModal(false) }); setShowModal(true) };

      // --- History ---
      const addToHistory = (src, tgt, prov, input, output) => { const entry = { id: genId(), ts: new Date().toISOString(), srcLang: src, tgtLang: tgt, provider: prov, inputPreview: input.substring(0, 200), outputPreview: output.substring(0, 200), fullInput: input, fullOutput: output }; const updated = [entry, ...history].slice(0, MAX_HISTORY); setHistory(updated); localStorage.setItem('translationHistory', JSON.stringify(updated)) };
      const loadFromHistory = entry => { setInputText(entry.fullInput); setAssembledText(entry.fullOutput); setSrcLang(entry.srcLang || 'Auto-detect'); setTgtLang(entry.tgtLang || 'English'); setActiveTab('text'); toast('Loaded from history') };
      const clearHistory = () => { confirmAction('Clear all history?', () => { setHistory([]); localStorage.setItem('translationHistory', '[]'); toast('History cleared.', 'info') }) };
      const deleteHistoryItem = id => { const u = history.filter(h => h.id !== id); setHistory(u); localStorage.setItem('translationHistory', JSON.stringify(u)) };

      // --- Translation ---
      const getTranslateOpts = (signal) => ({ apiKey: geminiKey, deeplApiKey: deeplKey, model: useCustomModel && customModel ? customModel : geminiModel, srcLang, tgtLang, glossary: terminology, instructions: customInstructions, signal, provider, libreUrl });

      const handleTranslateText = async (resume = false) => {
        if (!inputText.trim()) return setError('Paste some text to translate.');
        setIsTranslating(true); setProgress(0); setProgressLabel(resume ? 'Resuming...' : 'Preparing...'); setError('');
        if (!resume) { setAssembledText(''); setTranslatedChapters([]); }

        const ctrl = new AbortController(); abortRef.current = ctrl;
        const jobId = generateJobId(inputText);

        try {
          const opts = getTranslateOpts(ctrl.signal);
          const chunks = splitChunks(inputText, terminology.length);
          const useContext = contextAware && chunks.length > 1 && provider === 'gemini';

          let result = resume && activeSession ? activeSession.result : '';
          let ctx = resume && activeSession ? activeSession.ctx : '';
          let startIndex = resume && activeSession ? activeSession.completedCount : 0;

          const saveState = (res, c, count) => {
            const state = { result: res, ctx: c, completedCount: count, total: chunks.length };
            localStorage.setItem(jobId, JSON.stringify(state));
            setActiveSession(state);
          };

          if (provider === 'gemini' && enableStreaming) {
            // Streaming must be sequential (real-time display)
            for (let i = startIndex; i < chunks.length; i++) {
              setProgressLabel(`Streaming chunk ${i + 1}/${chunks.length}${useContext ? ' (with context)' : ''}...`);
              let chunkResult = '';
              const streamRes = await streamGemini(chunks[i], { ...opts, context: useContext ? ctx : undefined, onChunk: t => { chunkResult += t; result += t; setAssembledText(result) } });
              if (useContext) { ctx = streamRes.newContext || ctx; }
              setProgress(Math.floor(((i + 1) / chunks.length) * 100));
              saveState(result, ctx, i + 1);
            }
            setTranslatedChapters([{ title: 'Translated Document', content: result }]);
            localStorage.removeItem(jobId); setActiveSession(null);
          } else if (useContext) {
            // Sequential context-aware translation
            for (let i = startIndex; i < chunks.length; i++) {
              setProgressLabel(`Translating chunk ${i + 1}/${chunks.length} (with context)...`);
              const translated = await translateChunk(chunks[i], { ...opts, context: ctx });
              result += (result ? '\n' : '') + (translated.text || translated);
              ctx = translated.newContext || ctx;
              setAssembledText(result.replace(/\r\n/g, '\n').trim());
              setProgress(Math.floor(((i + 1) / chunks.length) * 100));
              saveState(result, ctx, i + 1);
            }
            const final = result.replace(/\r\n/g, '\n').trim();
            setAssembledText(final); setTranslatedChapters([{ title: 'Translated Document', content: final }]);
            localStorage.removeItem(jobId); setActiveSession(null);
          } else {
            // Parallel batch translation (no context)
            setProgressLabel(`Translating ${chunks.length - startIndex} remaining chunk(s) with ${Math.min(concurrency, chunks.length - startIndex)} parallel...`);
            let completed = startIndex;
            const remainingChunks = chunks.slice(startIndex);
            const results = await batchParallel(remainingChunks, async (chunk, idx) => {
              const translated = await translateChunk(chunk, opts);
              completed++; setProgress(Math.floor((completed / chunks.length) * 100));
              setProgressLabel(`Completed ${completed}/${chunks.length} chunks`);
              saveState(result + (result ? '\n' : '') + '[Partial Parallel Completion]', '', completed); // hard to save exact string state natively in parallel without risking order
              return translated;
            }, concurrency);

            const translated = results.map(r => typeof r === 'string' ? r : (r?.text ? r.text : (r?.error ? `\n\n[Error: ${r.error}]\n\n` : '')));
            const combinedNew = translated.join('').replace(/\r\n/g, '\n').trim();
            result = result ? result + '\n\n' + combinedNew : combinedNew;

            setAssembledText(result); setTranslatedChapters([{ title: 'Translated Document', content: result }]);
            localStorage.removeItem(jobId); setActiveSession(null);
          }
          addToHistory(srcLang, tgtLang, provider, inputText, assembledText || 'See output');
          toast('Translation complete!');
        } catch (e) {
          if (e.name !== 'AbortError') { setError(e.message); toast(e.message, 'error') } else toast('Translation paused.', 'info')
        }
        finally { setIsTranslating(false); setProgress(0); setProgressLabel(''); abortRef.current = null }
      };

      const handleTranslateEbook = async (chapters, resume = false) => {
        setIsTranslating(true); setProgress(0); setError('');
        if (!resume) { setAssembledText(''); setTranslatedChapters([]); }

        const ctrl = new AbortController(); abortRef.current = ctrl;
        const opts = getTranslateOpts(ctrl.signal);
        const useContext = contextAware && provider === 'gemini';
        let ctx = resume && activeSession ? activeSession.ctx : '';
        let done = resume && activeSession ? activeSession.completedCount : 0;

        const allParts = resume && activeSession ? [...activeSession.allParts] : [];
        const newChapters = resume && activeSession ? [...activeSession.newChapters] : [];
        const startChapterIdx = resume && activeSession ? activeSession.currentChapterIdx : 0;
        const startChunkIdx = resume && activeSession ? activeSession.currentChunkIdx : 0;

        const jobId = currentFileHash;
        const saveState = (c, count, chIdx, ckIdx, ap, nc) => {
          const state = { ctx: c, completedCount: count, currentChapterIdx: chIdx, currentChunkIdx: ckIdx, allParts: ap, newChapters: nc };
          localStorage.setItem(jobId, JSON.stringify(state));
          setActiveSession(state);
        };

        try {
          let totalChunks = 0;
          const chapterChunks = chapters.map(c => { const ch = splitChunks(c.text, terminology.length); totalChunks += ch.length; if (c.title.trim()) totalChunks++; return ch });

          for (let i = startChapterIdx; i < chapters.length; i++) {
            const ch = chapters[i]; let title = ch.title;
            const chunks = chapterChunks[i];

            // Translate title if starting fresh on this chapter
            if (i === startChapterIdx && startChunkIdx === 0 && title.trim()) {
              setProgressLabel(`Translating title: "${title.substring(0, 30)}..."`)
              try {
                const tRes = await translateChunk(title, { ...opts, context: useContext ? ctx : undefined });
                title = tRes.text || tRes;
              } catch (e) { title += ` [Error: ${e.message}]` }
              done++; setProgress(Math.floor((done / totalChunks) * 100));
              saveState(ctx, done, i, 0, allParts, newChapters); // save after title
            } else if (i > startChapterIdx && title.trim()) {
              // translate titles normally for subsequent chapters
              setProgressLabel(`Translating title: "${title.substring(0, 30)}..."`)
              try {
                const tRes = await translateChunk(title, { ...opts, context: useContext ? ctx : undefined });
                title = tRes.text || tRes;
              } catch (e) { title += ` [Error: ${e.message}]` }
              done++; setProgress(Math.floor((done / totalChunks) * 100));
            } else if (resume && i === startChapterIdx) {
              title = newChapters[i] ? newChapters[i].title : title; // use already translated title if resuming mid-chapter
            }

            if (useContext) {
              // Sequential context-aware translation for ebook chunks
              const parts = (resume && i === startChapterIdx && newChapters[i]?.content) ? newChapters[i].content.split(/(?=\n\n)/) : [];
              let ckStart = (i === startChapterIdx) ? startChunkIdx : 0;

              for (let j = ckStart; j < chunks.length; j++) {
                setProgressLabel(`Chapter ${i + 1}/${chapters.length}: chunk ${j + 1}/${chunks.length} (with context)...`);
                try {
                  const translated = await translateChunk(chunks[j], { ...opts, context: ctx });
                  parts.push(translated.text || translated);
                  ctx = translated.newContext || ctx;
                } catch (e) { parts.push(`\n\n[Error: ${e.message}]\n\n`) }
                done++; setProgress(Math.floor((done / totalChunks) * 100));

                // Save progress aggressively during context-aware mode
                const contentSoFar = parts.join('').replace(/\r\n/g, '\n').trim();
                const tempNewChapters = [...newChapters];
                tempNewChapters[i] = { originalTitle: ch.title, title, content: contentSoFar };
                const tempAllParts = [...allParts];
                tempAllParts[i] = `${title}\n\n${contentSoFar}`;

                setAssembledText(tempAllParts[i]); // Show progress in UI
                setTranslatedChapters(tempNewChapters); // Allow downloading partial epub
                saveState(ctx, done, i, j + 1, tempAllParts, tempNewChapters);
              }
              const content = parts.join('').replace(/\r\n/g, '\n').trim();
              newChapters[i] = { originalTitle: ch.title, title, content };
              allParts[i] = `${title}\n\n${content}`;
              setTranslatedChapters([...newChapters]);
            } else {
              // Parallel batch translation (no context)
              let ckStart = (i === startChapterIdx) ? startChunkIdx : 0;
              const remainingChunks = chunks.slice(ckStart);
              setProgressLabel(`Chapter ${i + 1}/${chapters.length}: translating ${remainingChunks.length} chunk(s) in parallel...`);

              const results = await batchParallel(remainingChunks, async (chunk, idx) => {
                const translated = await translateChunk(chunk, opts);
                done++; setProgress(Math.floor((done / totalChunks) * 100));
                setProgressLabel(`Chapter ${i + 1}/${chapters.length}: ${done}/${totalChunks} done`);
                return translated;
              }, concurrency);

              const newParts = results.map(r => typeof r === 'string' ? r : (r?.text ? r.text : (r?.error ? `\n\n[Error: ${r.error}]\n\n` : '')));
              const existingParts = (resume && i === startChapterIdx && newChapters[i]?.content) ? newChapters[i].content : '';
              const content = (existingParts ? existingParts + '\n\n' : '') + newParts.join('').replace(/\r\n/g, '\n').trim();

              newChapters[i] = { originalTitle: ch.title, title, content };
              allParts[i] = `${title}\n\n${content}`;
              setTranslatedChapters([...newChapters]); // Allow downloading partial epub
              saveState(ctx, done, i + 1, 0, allParts, newChapters); // save at end of chapter instead of per chunk here
            }
          }
          setTranslatedChapters(newChapters); const final = allParts.join('\n\n\n').trim(); setAssembledText(final);
          addToHistory(srcLang, tgtLang, provider, '[File upload]', final.substring(0, 2000));
          localStorage.removeItem(jobId); setActiveSession(null);
          toast('Translation complete!');
        } catch (e) {
          if (e.name !== 'AbortError') { setError(e.message); toast(e.message, 'error') } else toast('Paused.', 'info')
          setTranslatedChapters(resume && activeSession ? activeSession.newChapters : []); // Ensure latest saved state is ready for export
        }
        finally { setIsTranslating(false); setProgress(0); setProgressLabel(''); abortRef.current = null }
      };

      const cancelTranslation = () => { if (abortRef.current) abortRef.current.abort() };

      // --- File Handling ---
      const readFileAsText = f => new Promise((res, rej) => { const r = new FileReader(); r.onload = e => res(e.target.result); r.onerror = e => rej(e.target.error); r.readAsText(f) });

      const readPdf = async f => {
        if (!window.pdfjsLib) throw new Error('PDF.js not loaded.');
        const buf = await f.arrayBuffer(); const pdf = await window.pdfjsLib.getDocument({ data: buf }).promise; let txt = '';
        for (let i = 1; i <= pdf.numPages; i++) {
          const page = await pdf.getPage(i); const tc = await page.getTextContent(); if (!tc.items?.length) continue;
          const items = tc.items.sort((a, b) => a.transform[5] < b.transform[5] ? 1 : a.transform[5] > b.transform[5] ? -1 : a.transform[4] - b.transform[4]);
          let lastY = items[0].transform[5], line = '';
          for (const it of items) { const y = it.transform[5]; if (Math.abs(y - lastY) > it.height * 0.4) { txt += line + '\n'; if (Math.abs(y - lastY) > it.height * 1.2) txt += '\n'; line = '' } line += it.str + (it.str.endsWith(' ') ? '' : ' '); lastY = y }
          txt += line + '\n\n';
        } return txt;
      };

      const readEpub = async f => {
        if (!window.JSZip) throw new Error('JSZip not loaded.');
        const zip = await window.JSZip.loadAsync(f); const chapters = [];
        const cf = zip.file('META-INF/container.xml'); if (!cf) throw new Error('Invalid EPUB');
        const cc = await cf.async('text'); const cd = new DOMParser().parseFromString(cc, 'text/xml');
        const rp = cd.querySelector('rootfile')?.getAttribute('full-path'); if (!rp) throw new Error('No rootfile');
        const od = rp.substring(0, rp.lastIndexOf('/') + 1);
        const of2 = zip.file(rp); if (!of2) throw new Error('OPF not found');
        const oc = await of2.async('text'); const opf = new DOMParser().parseFromString(oc, 'text/xml');
        const ncxI = opf.querySelector('manifest item[media-type="application/x-dtbncx+xml"]');
        const ncxH = ncxI ? od + ncxI.getAttribute('href') : null;
        const navI = Array.from(opf.querySelectorAll('manifest item')).find(i => i.getAttribute('properties') === 'nav');
        const navH = navI ? od + navI.getAttribute('href') : null;
        const titles = new Map();
        if (ncxH) { const nf = zip.file(ncxH); if (nf) { const nc = await nf.async('text'); const nd = new DOMParser().parseFromString(nc, 'text/xml'); nd.querySelectorAll('navPoint').forEach(np => { const l = np.querySelector('navLabel text')?.textContent; const s = np.querySelector('content')?.getAttribute('src'); if (l && s) titles.set(s.split('#')[0], l.trim()) }) } }
        const extractText = n => { let t = ''; const blocks = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'div', 'li', 'blockquote', 'tr', 'section', 'article']; if (n.nodeType === 3) t += n.textContent; else if (n.nodeType === 1) { if (n.tagName.toLowerCase() === 'br') t += '\n'; for (const c of n.childNodes) t += extractText(c); if (blocks.includes(n.tagName.toLowerCase())) t = t.trimEnd() + '\n\n' } return t };
        for (const ir of opf.querySelectorAll('spine itemref')) {
          const id = ir.getAttribute('idref'); const mi = opf.querySelector(`manifest item[id="${id}"]`); const href = mi?.getAttribute('href'); if (!href) continue;
          const cp = od + href; if (cp === navH || cp === ncxH || href.toLowerCase().includes('toc.xhtml')) continue;
          const mt = mi.getAttribute('media-type'); if (mt && (mt === 'application/xhtml+xml' || mt === 'text/html')) { const file = zip.file(cp); if (file) { try { const html = await file.async('text'); const doc = new DOMParser().parseFromString(html, 'text/html'); doc.querySelectorAll('script,style').forEach(e => e.remove()); let txt = extractText(doc.body); let title = titles.get(href.split('#')[0]) || doc.querySelector('h1,h2,h3,h4')?.textContent.trim() || `Chapter ${chapters.length + 1}`; if (txt.trim()) chapters.push({ title, text: txt }) } catch (e) { } } }
        }
        if (!chapters.length) throw new Error('No readable text in EPUB.'); return { chapters };
      };

      const processFile = async f => {
        setUploadingFile(true); setError(''); setInputText(''); setAssembledText(''); setTranslatedChapters([]);
        const hashId = generateJobId(f.name + f.size, true);
        setCurrentFileHash(hashId);
        try {
          let data;
          if (f.type === 'text/plain') data = { chapters: [{ title: f.name, text: await readFileAsText(f) }] };
          else if (f.type === 'application/pdf') data = { chapters: [{ title: f.name, text: await readPdf(f) }] };
          else if (f.type === 'application/epub+zip') data = await readEpub(f);
          else throw new Error('Unsupported file type. Use .txt, .pdf, or .epub');
          const cleaned = data.chapters.map(c => ({ ...c, text: cleanText(c.text) }));

          const saved = localStorage.getItem(hashId);
          if (saved) {
            const willResume = confirm(`Found an incomplete translation for ${f.name}. Do you want to resume? (Cancel to start fresh)`);
            if (willResume) {
              setActiveSession(JSON.parse(saved));
              toast(`Resuming translation for ${f.name}...`, 'info');
              await handleTranslateEbook(cleaned, true);
              return;
            } else {
              localStorage.removeItem(hashId);
            }
          }

          toast(`Extracted from ${f.name}. Translating...`, 'info');
          await handleTranslateEbook(cleaned, false);
        } catch (e) { setError(e.message); toast(e.message, 'error') }
        finally { setUploadingFile(false); if (fileInputRef.current) fileInputRef.current.value = '' }
      };

      // --- Drag & Drop ---
      const onDragOver = e => { e.preventDefault(); setIsDragOver(true) };
      const onDragLeave = () => setIsDragOver(false);
      const onDrop = e => { e.preventDefault(); setIsDragOver(false); const f = e.dataTransfer.files[0]; if (f) processFile(f) };

      // --- Download Handlers ---
      const handleDownloadPDF = () => {
        if (!translatedChapters.length) return setError('No content to download.'); setDownloadingPdf(true); setError('');
        try {
          const { jsPDF } = window.jspdf; const doc = new jsPDF(); doc.setFont('Helvetica', 'normal');
          const lh = 7, m = 10, mw = doc.internal.pageSize.width - 2 * m; let y = m;
          translatedChapters.forEach((ch, i) => {
            if (i > 0) { doc.addPage(); y = m } if (ch.title.trim()) { doc.setFontSize(16); doc.text(ch.title, m, y); y += lh * 2 } doc.setFontSize(12);
            ch.content.split(/\n\s*\n/).filter(p => p.trim()).forEach(p => { doc.splitTextToSize(p.trim(), mw).forEach(l => { if (y + lh > doc.internal.pageSize.height - m) { doc.addPage(); y = m } doc.text(l, m, y); y += lh }); y += lh * 0.5 })
          });
          doc.save(`translated_${tgtLang.toLowerCase().replace(/\s/g, '-')}.pdf`); toast('PDF downloaded!')
        } catch (e) { setError(`PDF error: ${e.message}`) } finally { setDownloadingPdf(false) }
      };

      const handleDownloadEPUB = async () => {
        if (!translatedChapters.length) return setError('No content to download.'); setDownloadingEpub(true); setError('');
        try {
          const j = new jEpub(); j.init({ title: `Translated (${tgtLang})`, author: 'Gemini Translator', publisher: 'Gemini Translator', description: `Translated to ${tgtLang}`, lang: tgtLang.split(/[-_ ]/)[0].toLowerCase(), version: '3.0', uniqueIdentifier: `urn:uuid:${crypto.randomUUID()}` });
          translatedChapters.forEach(ch => {
            const paragraphs = ch.content.split(/\n\s*\n/).filter(p => p.trim());
            j.add(ch.title, paragraphs);
          });
          const blob = await j.generate(); const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `translated_${tgtLang.toLowerCase().replace(/\s/g, '-')}.epub`; a.click(); URL.revokeObjectURL(a.href); toast('EPUB downloaded!')
        } catch (e) { setError(`EPUB error: ${e.message}`) } finally { setDownloadingEpub(false) }
      };

      const handleDownloadDOCX = async () => {
        if (!translatedChapters.length) return setError('No content to download.'); setDownloadingDocx(true); setError('');
        try {
          const { Document, Packer, Paragraph, TextRun, HeadingLevel, PageBreak } = window.docx;
          const sections = translatedChapters.map((ch, i) => ({
            properties: i > 0 ? { page: { pageBreaks: { before: true } } } : {}, children: [
              ...(ch.title.trim() ? [new Paragraph({ text: ch.title, heading: HeadingLevel.HEADING_1, spacing: { after: 200 } })] : []),
              ...ch.content.split(/\n\s*\n/).filter(p => p.trim()).map(p => new Paragraph({ children: [new TextRun(p.trim())], spacing: { after: 120 } }))
            ]
          }));
          const doc = new Document({ sections }); const blob = await Packer.toBlob(doc);
          const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = `translated_${tgtLang.toLowerCase().replace(/\s/g, '-')}.docx`; a.click(); URL.revokeObjectURL(a.href); toast('DOCX downloaded!')
        } catch (e) { setError(`DOCX error: ${e.message}`) } finally { setDownloadingDocx(false) }
      };

      // --- Helpers for render ---
      const btn = (props, ...ch) => h('button', props, ...ch);
      const ic = (Icon, size = 18) => h(Icon, { size, className: 'shrink-0' });
      const disabled = isTranslating || uploadingFile;
      const activeModel = useCustomModel && customModel ? customModel : geminiModel;

      // ═══════════════════════════════════════
      // RENDER
      // ═══════════════════════════════════════
      const secHeader = (title, icon, isOpen, toggle) => h('button', { onClick: toggle, className: 'flex items-center justify-between w-full text-left text-xl font-bold text-gray-800 dark:text-gray-200 mb-2 p-3 bg-gray-100 dark:bg-gray-800 rounded-lg hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors', 'aria-expanded': isOpen }, h('span', { className: 'flex items-center gap-2' }, ic(icon, 22), title), ic(isOpen ? ChevronUp : ChevronDown, 20));

      return h('div', { className: 'min-h-screen bg-gray-50 dark:bg-gray-950 font-sans text-gray-800 dark:text-gray-200 transition-colors' },
        // HEADER
        h('header', { className: 'sticky top-0 z-40 bg-white/80 dark:bg-gray-900/80 backdrop-blur-md border-b border-gray-200 dark:border-gray-800 px-4 py-3' },
          h('div', { className: 'max-w-5xl mx-auto flex items-center justify-between' },
            h('div', { className: 'flex items-center gap-3' },
              h('h1', { className: 'text-2xl sm:text-3xl font-extrabold bg-gradient-to-r from-indigo-600 to-purple-600 bg-clip-text text-transparent' }, 'Gemini Translator'),
              h('span', { className: 'text-xs font-medium text-gray-400 bg-gray-100 dark:bg-gray-800 px-2 py-0.5 rounded-full' }, `v${VERSION}`)
            ),
            h('button', { onClick: () => setDarkMode(!darkMode), className: 'p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700 transition-colors', 'aria-label': 'Toggle dark mode' }, ic(darkMode ? Sun : Moon, 22))
          )
        ),

        // MAIN
        h('main', { className: 'max-w-5xl mx-auto px-4 py-6 space-y-6' },

          // TABS
          h('div', { className: 'flex border-b border-gray-200 dark:border-gray-700 gap-1' },
            [['text', 'Text & File', Clipboard], ['history', 'History', History], ['url', 'URL (Info)', Link]].map(([key, label, Icon]) =>
              h('button', { key, onClick: () => setActiveTab(key), className: `py-2.5 px-4 text-sm font-semibold rounded-t-lg transition-colors flex items-center gap-2 ${activeTab === key ? 'bg-indigo-600 text-white shadow-md' : 'text-gray-600 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800'}` }, ic(Icon, 18), label)
            )
          ),

          // TAB: TEXT & FILE
          activeTab === 'text' && h('div', { className: 'space-y-6' },

            // Provider + Model Config
            h('div', { className: 'grid grid-cols-1 sm:grid-cols-2 gap-4 p-4 bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800' },
              h('div', null,
                h('label', { className: 'block text-sm font-semibold mb-1' }, 'Translation Provider'),
                h('select', { value: provider, onChange: e => { setProvider(e.target.value) }, disabled, className: 'w-full p-2.5 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-sm focus:ring-2 focus:ring-indigo-500' },
                  h('option', { value: 'gemini' }, 'Gemini (AI)'), h('option', { value: 'deepl' }, 'DeepL'), h('option', { value: 'libre' }, 'LibreTranslate (Free)')
                )
              ),
              provider === 'gemini' && h('div', null,
                h('label', { className: 'block text-sm font-semibold mb-1' }, 'Gemini Model'),
                !useCustomModel ? h('select', { value: geminiModel, onChange: e => { setGeminiModel(e.target.value); localStorage.setItem('geminiModel', e.target.value) }, disabled, className: 'w-full p-2.5 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-sm focus:ring-2 focus:ring-indigo-500' },
                  availableModels.length > 0 ? availableModels.map(m => h('option', { key: m.id, value: m.id }, m.name)) :
                    [h('option', { key: '2.5f', value: 'gemini-2.5-flash' }, 'Gemini 2.5 Flash'), h('option', { key: '2.0f', value: 'gemini-2.0-flash' }, 'Gemini 2.0 Flash'), h('option', { key: '2.5p', value: 'gemini-2.5-pro' }, 'Gemini 2.5 Pro')]
                ) : h('input', { type: 'text', value: customModel, onChange: e => setCustomModel(e.target.value), placeholder: 'e.g. gemini-3-flash', disabled, className: 'w-full p-2.5 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-sm focus:ring-2 focus:ring-indigo-500' }),
                h('label', { className: 'flex items-center gap-2 mt-2 text-xs text-gray-500 cursor-pointer' }, h('input', { type: 'checkbox', checked: useCustomModel, onChange: e => setUseCustomModel(e.target.checked), className: 'rounded' }), 'Use custom model name')
              ),
              provider === 'gemini' && h('div', { className: 'flex flex-col sm:flex-row gap-4 sm:gap-6 mt-1' },
                h('label', { className: 'flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400 cursor-pointer' }, h('input', { type: 'checkbox', checked: enableStreaming, onChange: e => setEnableStreaming(e.target.checked), className: 'rounded accent-indigo-600' }), ic(Zap, 16), 'Streaming'),
                h('label', { className: 'flex items-center gap-2 text-sm text-gray-600 dark:text-gray-400 cursor-pointer', title: 'Carries character names and plot context between chunks (slower, sequential translation)' }, h('input', { type: 'checkbox', checked: contextAware, onChange: e => setContextAware(e.target.checked), className: 'rounded accent-indigo-600' }), ic(BookText, 16), 'Context-Aware')
              ),
              h('div', { className: 'flex items-center gap-3 col-span-full' },
                h('label', { className: `text-sm font-semibold whitespace-nowrap ${contextAware && provider === 'gemini' ? 'text-gray-400' : ''}` }, `Parallel Requests: ${concurrency}`),
                h('input', { type: 'range', min: 1, max: 10, value: concurrency, onChange: e => setConcurrency(parseInt(e.target.value)), className: 'flex-1 accent-indigo-600 h-2 cursor-pointer', disabled: disabled || (contextAware && provider === 'gemini') }),
                h('span', { className: 'text-xs text-gray-400 whitespace-nowrap' }, contextAware && provider === 'gemini' ? 'Disabled in context mode' : (concurrency === 1 ? 'Slower, safer' : concurrency >= 8 ? 'Fastest' : 'Balanced'))
              )
            ),

            // Language selectors
            h('div', { className: 'grid grid-cols-1 sm:grid-cols-2 gap-4' },
              h('div', null,
                h('label', { className: 'block text-sm font-semibold mb-1' }, 'Source Language'),
                h('select', { value: srcLang, onChange: e => setSrcLang(e.target.value), disabled, className: 'w-full p-2.5 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-sm focus:ring-2 focus:ring-indigo-500' }, LANGUAGES.map(l => h('option', { key: l, value: l }, l)))
              ),
              h('div', null,
                h('label', { className: 'block text-sm font-semibold mb-1' }, 'Target Language'),
                h('select', { value: tgtLang, onChange: e => setTgtLang(e.target.value), disabled, className: 'w-full p-2.5 rounded-lg border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-sm focus:ring-2 focus:ring-indigo-500' }, TARGET_LANGUAGES.map(l => h('option', { key: l, value: l }, l)))
              )
            ),

            // File upload + Drag & Drop
            h('div', { onDragOver, onDragLeave, onDrop, className: `p-4 bg-white dark:bg-gray-900 rounded-xl border-2 border-dashed border-gray-300 dark:border-gray-700 transition-all ${isDragOver ? 'drop-zone-active' : ''}` },
              h('div', { className: 'text-center mb-3' },
                h('p', { className: 'text-sm text-gray-500 dark:text-gray-400' }, 'Drag & drop a file here, or'),
                btn({ onClick: () => fileInputRef.current?.click(), disabled, className: 'mt-2 px-5 py-2.5 bg-purple-600 text-white font-semibold rounded-lg shadow hover:bg-purple-700 transition-all inline-flex items-center gap-2 disabled:opacity-50' },
                  (uploadingFile || isTranslating) ? ic(Loader2, 18) : ic(Upload, 18),
                  uploadingFile ? 'Processing...' : (isTranslating ? `Translating (${progress}%)` : 'Choose File (TXT, PDF, EPUB)')
                ),
                h('input', { type: 'file', ref: fileInputRef, onChange: e => { const f = e.target.files[0]; if (f) processFile(f) }, accept: '.txt,.pdf,.epub,application/epub+zip', className: 'hidden', disabled })
              ),
              isTranslating && h('div', { className: 'mt-3' },
                h('div', { className: 'flex items-center justify-between text-xs text-gray-500 mb-1' }, h('span', null, progressLabel), h('span', null, `${progress}%`)),
                h('div', { className: 'w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2' }, h('div', { className: 'bg-indigo-600 h-2 rounded-full transition-all', style: { width: `${progress}%` } }))
              ),
              (chapters.length > 0 && !isTranslating) && h('div', { className: 'mt-3 text-xs text-gray-500 dark:text-gray-400 px-1 flex flex-col items-center gap-1' },
                h('span', null, `Document Loaded: ${chapters.length} chapters · ~${Math.ceil(chapters.reduce((acc, ch) => acc + ch.text.length, 0) / 4).toLocaleString()} tokens`),
                provider === 'gemini' && h('span', null, `Estimated Cost: ~ $${((Math.ceil(chapters.reduce((acc, ch) => acc + ch.text.length, 0) / 4) / 1000000) * 0.075).toFixed(4)} (2.5 Flash)`)
              )
            ),

            // Input/Output areas
            h('div', { className: sideBySide ? 'grid grid-cols-1 md:grid-cols-2 gap-4' : 'space-y-4' },
              // Input
              h('div', null,
                h('div', { className: 'flex items-center justify-between mb-1' },
                  h('label', { className: 'text-sm font-semibold' }, 'Input Text'),
                  h('span', { className: 'text-xs text-gray-400' }, `${wordCount(inputText)} words · ${charCount(inputText)} chars`)
                ),
                h('textarea', { value: inputText, onChange: e => setInputText(e.target.value), disabled, placeholder: 'Paste your content here...', className: 'w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg shadow-sm focus:ring-2 focus:ring-indigo-500 resize-y text-sm', style: { minHeight: '250px' }, 'aria-label': 'Input text for translation' }),
                h('div', { className: 'flex flex-wrap gap-2 mt-2' },
                  btn({ onClick: async () => { try { const t = await navigator.clipboard.readText(); setInputText(p => p + t); toast('Pasted!') } catch (e) { setError(e.message) } }, disabled, className: 'px-3 py-1.5 bg-blue-500 text-white text-sm font-medium rounded-lg hover:bg-blue-600 transition-colors inline-flex items-center gap-1.5', 'aria-label': 'Paste text from clipboard' }, ic(Clipboard, 15), 'Paste'),
                  btn({ onClick: () => { if (inputText) copyText(inputText).then(() => toast('Copied!')) }, disabled, className: 'px-3 py-1.5 bg-gray-600 text-white text-sm font-medium rounded-lg hover:bg-gray-700 transition-colors inline-flex items-center gap-1.5', 'aria-label': 'Copy input text' }, ic(Copy, 15), 'Copy'),
                  btn({ onClick: () => { setInputText(''); setAssembledText(''); setTranslatedChapters([]); setError('') }, disabled, className: 'px-3 py-1.5 bg-red-500 text-white text-sm font-medium rounded-lg hover:bg-red-600 transition-colors inline-flex items-center gap-1.5', 'aria-label': 'Clear input' }, ic(XCircle, 15), 'Clear'),
                  btn({ onClick: () => { const t = inputText; setInputText(assembledText); setAssembledText(t) }, disabled, className: 'px-3 py-1.5 bg-gray-200 dark:bg-gray-700 text-gray-700 dark:text-gray-200 text-sm font-medium rounded-lg hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors inline-flex items-center gap-1.5', 'aria-label': 'Swap input and output text' }, ic(RefreshCcw, 15), 'Swap'),
                  btn({ onClick: () => setSideBySide(!sideBySide), className: 'px-3 py-1.5 bg-indigo-100 dark:bg-indigo-900 text-indigo-700 dark:text-indigo-300 text-sm font-medium rounded-lg hover:bg-indigo-200 dark:hover:bg-indigo-800 transition-colors inline-flex items-center gap-1.5 ml-auto', 'aria-label': 'Toggle side by side view' }, ic(sideBySide ? Rows2 : Columns2, 15), sideBySide ? 'Stack' : 'Split')
                )
              ),

              // Output
              assembledText && h('div', null,
                h('div', { className: 'flex items-center justify-between mb-1' },
                  h('label', { className: 'text-sm font-semibold text-green-700 dark:text-green-400' }, `Translated (${tgtLang})`),
                  h('span', { className: 'text-xs text-gray-400' }, `${wordCount(assembledText)} words · ${charCount(assembledText)} chars`)
                ),
                h('textarea', { value: assembledText, readOnly: true, className: 'w-full p-3 border border-green-300 dark:border-green-800 bg-green-50 dark:bg-gray-900 rounded-lg shadow-inner focus:outline-none resize-y text-sm', style: { minHeight: '250px' }, 'aria-label': 'Translated output text' }),
                h('div', { className: 'flex flex-wrap gap-2 mt-2 items-center justify-between' },
                  btn({ onClick: () => { if (assembledText) copyText(assembledText).then(() => toast('Copied!')) }, className: 'px-3 py-1.5 bg-gray-600 text-white text-sm font-medium rounded-lg hover:bg-gray-700 transition-colors inline-flex items-center gap-1.5', 'aria-label': 'Copy translation' }, ic(Copy, 15), 'Copy'),
                  h('a', { href: './EPUB-Studio/index.html', target: '_blank', className: 'text-xs text-indigo-600 dark:text-indigo-400 hover:underline inline-flex items-center gap-1 font-semibold' }, ic(BookText, 14), 'Open EPUB Studio')
                )
              )
            ),

            // Translate + Cancel buttons
            h('div', { className: 'flex flex-col gap-2' },
              inputText.length > 0 && h('div', { className: 'text-xs text-gray-500 dark:text-gray-400 px-1 flex justify-between' },
                h('span', null, `Estimated Input: ~${Math.ceil(charCount(inputText) / 4).toLocaleString()} tokens`),
                provider === 'gemini' && h('span', null, `~ $${((Math.ceil(charCount(inputText) / 4) / 1000000) * 0.075).toFixed(4)} (2.5 Flash)`)
              ),
              h('div', { className: 'flex flex-col sm:flex-row items-center gap-3' },
                btn({ onClick: () => handleTranslateText(false), disabled, className: 'w-full sm:w-auto px-8 py-3 bg-gradient-to-r from-indigo-600 to-purple-600 text-white font-bold rounded-full shadow-lg hover:shadow-xl hover:scale-105 transition-all flex items-center justify-center text-lg disabled:opacity-50 disabled:hover:scale-100', title: 'Ctrl+Enter' },
                  isTranslating ? ic(Loader2, 22) : ic(BookText, 22),
                  h('span', { className: 'ml-2' }, isTranslating ? `Translating... (${progress}%)` : (activeSession ? 'Restart' : 'Translate'))
                ),
                (!isTranslating && activeSession) && btn({ onClick: () => handleTranslateText(true), className: 'w-full sm:w-auto px-8 py-3 bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold rounded-full shadow-lg hover:shadow-xl hover:scale-105 transition-all flex items-center justify-center text-lg' },
                  ic(RotateCcw, 22),
                  h('span', { className: 'ml-2' }, 'Resume')
                ),
                isTranslating && btn({ onClick: cancelTranslation, className: 'px-5 py-2.5 bg-red-500 text-white font-semibold rounded-full shadow hover:bg-red-600 transition-all flex items-center gap-2', 'aria-label': 'Cancel translation' }, ic(Square, 18), 'Pause'),
                isTranslating && h('div', { className: 'w-full' },
                  h('p', { className: 'text-xs text-gray-500 text-center mb-1' }, progressLabel),
                  h('div', { className: 'w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2' }, h('div', { className: 'bg-indigo-600 h-2 rounded-full transition-all', style: { width: `${progress}%` } }))
                )
              )
            )
          ),

          // Download buttons
          assembledText && h('div', { className: 'flex flex-wrap justify-center gap-3 pt-4 border-t border-gray-200 dark:border-gray-700' },
            btn({ onClick: () => copyText(assembledText).then(() => toast('Copied!')), className: 'px-5 py-2.5 bg-blue-500 text-white font-semibold rounded-full shadow hover:bg-blue-600 transition-all inline-flex items-center gap-2', title: 'Ctrl+Shift+C' }, ic(Copy, 18), 'Copy'),
            btn({ onClick: handleDownloadEPUB, disabled: downloadingEpub, className: 'px-5 py-2.5 bg-teal-500 text-white font-semibold rounded-full shadow hover:bg-teal-600 transition-all inline-flex items-center gap-2 disabled:opacity-50' }, downloadingEpub ? ic(Loader2, 18) : ic(Download, 18), 'EPUB'),
            btn({ onClick: handleDownloadPDF, disabled: downloadingPdf, className: 'px-5 py-2.5 bg-red-500 text-white font-semibold rounded-full shadow hover:bg-red-600 transition-all inline-flex items-center gap-2 disabled:opacity-50' }, downloadingPdf ? ic(Loader2, 18) : ic(Download, 18), 'PDF'),
            btn({ onClick: handleDownloadDOCX, disabled: downloadingDocx, className: 'px-5 py-2.5 bg-blue-700 text-white font-semibold rounded-full shadow hover:bg-blue-800 transition-all inline-flex items-center gap-2 disabled:opacity-50' }, downloadingDocx ? ic(Loader2, 18) : ic(FileDown, 18), 'DOCX')
          ),

          // Custom Instructions
          h('div', { className: 'p-4 bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800' },
            h('label', { className: 'block text-sm font-semibold mb-1' }, 'Custom Translation Instructions'),
            h('textarea', { value: customInstructions, onChange: e => setCustomInstructions(e.target.value), disabled, placeholder: 'e.g., "Use formal tone", "Keep character names in original language", "Output in British English"', className: 'w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg text-sm resize-y focus:ring-2 focus:ring-indigo-500', rows: 2 }),
            h('p', { className: 'text-xs text-gray-400 mt-1' }, 'These instructions are added to every translation prompt alongside the glossary.')
          ),

          // Glossary
          h('div', { className: 'bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 overflow-hidden' },
            h('div', { className: 'p-4' },
              h('label', { className: 'block text-sm font-semibold mb-1' }, 'Glossary'),
              h('textarea', { value: terminology, onChange: e => setTerminology(e.target.value), disabled, placeholder: 'Enter terms to ensure accurate translation...', className: 'w-full p-3 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-900 rounded-lg text-sm resize-y focus:ring-2 focus:ring-indigo-500', rows: 4 }),
              h('div', { className: 'flex flex-wrap gap-2 mt-2' },
                btn({ onClick: async () => { try { const t = await navigator.clipboard.readText(); setTerminology(p => p + t); toast('Pasted!') } catch (e) { } }, disabled, className: 'px-3 py-1.5 bg-blue-500 text-white text-xs font-medium rounded-lg hover:bg-blue-600 inline-flex items-center gap-1' }, ic(Clipboard, 14), 'Paste'),
                btn({ onClick: () => { if (terminology) copyText(terminology).then(() => toast('Glossary copied!')) }, disabled, className: 'px-3 py-1.5 bg-gray-600 text-white text-xs font-medium rounded-lg hover:bg-gray-700 inline-flex items-center gap-1' }, ic(Copy, 14), 'Copy'),
                btn({ onClick: () => confirmAction('Clear glossary text?', () => { setTerminology(''); setActiveGlossaryId(null) }), disabled, className: 'px-3 py-1.5 bg-red-500 text-white text-xs font-medium rounded-lg hover:bg-red-600 inline-flex items-center gap-1' }, ic(XCircle, 14), 'Clear'),
                btn({ onClick: () => glossaryFileRef.current?.click(), disabled, className: 'px-3 py-1.5 bg-purple-500 text-white text-xs font-medium rounded-lg hover:bg-purple-600 inline-flex items-center gap-1' }, ic(Upload, 14), 'Upload'),
                h('input', { type: 'file', ref: glossaryFileRef, onChange: handleGlossaryFile, className: 'hidden', accept: '.txt,.md,.json,.csv,.xml,.html' })
              )
            ),

            // Profile Manager
            h('div', { className: 'border-t border-gray-200 dark:border-gray-800' },
              secHeader('Manage Profiles', BookText, showGlossaryManager, () => setShowGlossaryManager(!showGlossaryManager)),
              h('div', { className: `collapsible ${showGlossaryManager ? 'open' : ''}` },
                h('div', { className: 'p-4 space-y-3' },
                  h('div', { className: 'flex gap-2' },
                    h('input', { type: 'text', value: newGlossaryName, onChange: e => setNewGlossaryName(e.target.value), disabled, placeholder: 'Profile name...', className: 'flex-1 p-2 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500' }),
                    btn({ onClick: handleSaveGlossary, disabled, className: 'px-4 py-2 bg-purple-600 text-white text-sm font-semibold rounded-lg hover:bg-purple-700' }, 'Save')
                  ),
                  h('div', { className: 'flex flex-wrap gap-2' },
                    btn({ onClick: setDefaultGloss, disabled: !activeGlossaryId || disabled, className: 'px-3 py-1.5 bg-green-500 text-white text-xs font-semibold rounded-lg hover:bg-green-600 disabled:opacity-50' }, 'Set Default'),
                    btn({ onClick: clearDefaultGloss, disabled: !defaultGlossaryName || disabled, className: 'px-3 py-1.5 bg-orange-500 text-white text-xs font-semibold rounded-lg hover:bg-orange-600 disabled:opacity-50' }, 'Clear Default'),
                    btn({ onClick: exportGlossaries, className: 'px-3 py-1.5 bg-indigo-500 text-white text-xs font-semibold rounded-lg hover:bg-indigo-600 inline-flex items-center gap-1' }, ic(Download, 14), 'Export All'),
                    h('label', { className: 'px-3 py-1.5 bg-indigo-500 text-white text-xs font-semibold rounded-lg hover:bg-indigo-600 inline-flex items-center gap-1 cursor-pointer' }, ic(Upload, 14), 'Import', h('input', { type: 'file', onChange: importGlossaries, className: 'hidden', accept: '.json' }))
                  ),
                  defaultGlossaryName && h('p', { className: 'text-xs text-indigo-500' }, 'Default: ', h('strong', null, defaultGlossaryName)),
                  savedGlossaries.length > 0 && h('div', { className: 'max-h-64 overflow-y-auto space-y-2' },
                    [...savedGlossaries].sort((a, b) => a.name === activeGlossaryId ? -1 : b.name === activeGlossaryId ? 1 : a.name.localeCompare(b.name)).map((g, i) =>
                      h('div', { key: i, className: `flex items-center justify-between p-3 rounded-lg border ${activeGlossaryId === g.name ? 'border-indigo-400 bg-indigo-50 dark:bg-indigo-900/30' : 'border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-800'}` },
                        h('span', { className: 'text-sm font-medium truncate flex-1' }, g.name, defaultGlossaryName === g.name && h('span', { className: 'text-xs text-indigo-500 ml-1' }, '★')),
                        h('div', { className: 'flex gap-1 ml-2' },
                          btn({ onClick: () => handleLoadGlossary(g), disabled, className: 'px-2.5 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600' }, 'Load'),
                          activeGlossaryId === g.name && btn({ onClick: () => handleUpdateGlossary(g.name), disabled, className: 'px-2.5 py-1 text-xs bg-green-500 text-white rounded hover:bg-green-600' }, 'Update'),
                          btn({ onClick: () => handleDeleteGlossary(g.name), disabled, className: 'px-2.5 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600' }, 'Del')
                        )
                      )
                    )
                  )
                )
              )
            )
          ),

          // API Keys / Settings
          h('div', { className: 'bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800 overflow-hidden' },
            secHeader('Settings & API Keys', Settings, showSettings, () => setShowSettings(!showSettings)),
            h('div', { className: `collapsible ${showSettings ? 'open' : ''}` },
              h('div', { className: 'p-4 space-y-4' },
                // Gemini Key
                h('div', null,
                  h('label', { className: 'block text-sm font-semibold mb-1' }, 'Gemini API Key'),
                  h('div', { className: 'flex gap-2' },
                    h('div', { className: 'relative flex-1' },
                      h('input', { type: showGeminiKey ? 'text' : 'password', value: geminiKeyInput, onChange: e => setGeminiKeyInput(e.target.value), disabled, placeholder: 'Enter Gemini API key...', className: 'w-full p-2.5 pr-10 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500' }),
                      btn({ onClick: () => setShowGeminiKey(!showGeminiKey), className: 'absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600', 'aria-label': 'Toggle key visibility' }, ic(showGeminiKey ? EyeOff : Eye, 16))
                    )
                  ),
                  h('div', { className: 'flex flex-wrap gap-2 mt-2' },
                    btn({ onClick: saveGeminiKey, className: 'px-3 py-1.5 bg-green-500 text-white text-xs font-semibold rounded-lg hover:bg-green-600' }, 'Save'),
                    btn({ onClick: async () => { try { const t = await navigator.clipboard.readText(); setGeminiKeyInput(t); toast('Pasted!') } catch (e) { } }, className: 'px-3 py-1.5 bg-blue-500 text-white text-xs font-semibold rounded-lg hover:bg-blue-600' }, 'Paste'),
                    btn({ onClick: clearGeminiKey, className: 'px-3 py-1.5 bg-red-500 text-white text-xs font-semibold rounded-lg hover:bg-red-600' }, 'Clear')
                  ),
                  geminiKey && h('p', { className: 'text-xs text-green-600 dark:text-green-400 mt-1' }, '✓ Gemini API key saved. ', availableModels.length > 0 && `${availableModels.length} models available.`)
                ),
                // DeepL Key
                (provider === 'deepl' || deeplKey) && h('div', null,
                  h('label', { className: 'block text-sm font-semibold mb-1' }, 'DeepL API Key'),
                  h('div', { className: 'relative' },
                    h('input', { type: showDeeplKey ? 'text' : 'password', value: deeplKeyInput, onChange: e => setDeeplKeyInput(e.target.value), disabled, placeholder: 'Enter DeepL API key...', className: 'w-full p-2.5 pr-10 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500' }),
                    btn({ onClick: () => setShowDeeplKey(!showDeeplKey), className: 'absolute right-2 top-1/2 -translate-y-1/2 text-gray-400 hover:text-gray-600', 'aria-label': 'Toggle key visibility' }, ic(showDeeplKey ? EyeOff : Eye, 16))
                  ),
                  h('div', { className: 'flex gap-2 mt-2' },
                    btn({ onClick: saveDeeplKey, className: 'px-3 py-1.5 bg-green-500 text-white text-xs font-semibold rounded-lg hover:bg-green-600' }, 'Save'),
                    btn({ onClick: clearDeeplKey, className: 'px-3 py-1.5 bg-red-500 text-white text-xs font-semibold rounded-lg hover:bg-red-600' }, 'Clear')
                  ),
                  deeplKey && h('p', { className: 'text-xs text-green-600 dark:text-green-400 mt-1' }, '✓ DeepL API key saved.'),
                  h('p', { className: 'text-xs text-gray-400 mt-1' }, 'Free tier: 500K chars/month. Key ending in :fx uses free endpoint.')
                ),
                // LibreTranslate URL
                provider === 'libre' && h('div', null,
                  h('label', { className: 'block text-sm font-semibold mb-1' }, 'LibreTranslate URL'),
                  h('div', { className: 'flex gap-2' },
                    h('input', { type: 'text', value: libreUrl, onChange: e => setLibreUrl(e.target.value), className: 'flex-1 p-2.5 border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 rounded-lg text-sm focus:ring-2 focus:ring-indigo-500' }),
                    btn({ onClick: saveLibreUrl, className: 'px-3 py-1.5 bg-green-500 text-white text-xs font-semibold rounded-lg hover:bg-green-600' }, 'Save')
                  ),
                  h('p', { className: 'text-xs text-gray-400 mt-1' }, 'Default: libretranslate.com. Use your own instance for better reliability.')
                )
              )
            )
          )
        ),

        // TAB: HISTORY
        activeTab === 'history' && h('div', { className: 'space-y-4' },
          h('div', { className: 'flex items-center justify-between' },
            h('h2', { className: 'text-xl font-bold' }, 'Translation History'),
            history.length > 0 && btn({ onClick: clearHistory, className: 'px-3 py-1.5 bg-red-500 text-white text-xs font-semibold rounded-lg hover:bg-red-600 inline-flex items-center gap-1' }, ic(Trash2, 14), 'Clear All')
          ),
          history.length === 0 ? h('p', { className: 'text-gray-500 dark:text-gray-400 text-center py-8' }, 'No translation history yet.') :
            h('div', { className: 'space-y-3' }, history.map(entry =>
              h('div', { key: entry.id, className: 'p-4 bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800' },
                h('div', { className: 'flex items-center justify-between mb-2' },
                  h('div', { className: 'flex items-center gap-2 text-xs text-gray-500' },
                    h('span', { className: 'font-medium text-indigo-600 dark:text-indigo-400' }, entry.provider),
                    h('span', null, '·'),
                    h('span', null, `${entry.srcLang || 'Auto'} → ${entry.tgtLang}`),
                    h('span', null, '·'),
                    h('span', null, new Date(entry.ts).toLocaleString())
                  ),
                  h('div', { className: 'flex gap-1' },
                    btn({ onClick: () => loadFromHistory(entry), className: 'px-2.5 py-1 text-xs bg-blue-500 text-white rounded hover:bg-blue-600' }, 'Load'),
                    btn({ onClick: () => deleteHistoryItem(entry.id), className: 'px-2.5 py-1 text-xs bg-red-500 text-white rounded hover:bg-red-600' }, 'Del')
                  )
                ),
                h('p', { className: 'text-sm text-gray-600 dark:text-gray-400 line-clamp-2' }, entry.outputPreview || entry.inputPreview)
              )
            ))
        ),

        // TAB: URL INFO
        activeTab === 'url' && h('div', { className: 'p-6 bg-white dark:bg-gray-900 rounded-xl border border-gray-200 dark:border-gray-800' },
          h('h2', { className: 'text-xl font-bold mb-3' }, 'URL Content Information'),
          h('p', { className: 'text-gray-600 dark:text-gray-400 leading-relaxed' }, h('strong', null, 'Note:'), ' This app runs in your browser and cannot fetch content from URLs directly.', h('br'), h('br'), h('strong', null, 'Workaround:'), ' Copy text from the website and paste it into the Text & File tab.')
        ),

        // Error display
        error && h('div', { className: 'flex items-center justify-between p-4 bg-red-50 dark:bg-red-900/20 border-l-4 border-red-500 rounded-r-lg', 'role': 'alert' },
          h('p', { className: 'text-sm font-medium text-red-700 dark:text-red-400' }, error),
          btn({ onClick: () => setError(''), className: 'text-red-500 hover:text-red-700', 'aria-label': 'Dismiss error' }, ic(X, 18))
        )
      ),

        // TOASTS
        h('div', { className: 'fixed bottom-4 right-4 z-50 space-y-2', role: 'status', 'aria-live': 'polite' },
          toasts.map(t => h('div', { key: t.id, className: `toast-enter flex items-center gap-2 px-4 py-3 rounded-lg shadow-lg text-sm font-medium ${t.type === 'error' ? 'bg-red-600 text-white' : t.type === 'info' ? 'bg-blue-600 text-white' : 'bg-green-600 text-white'}` },
            ic(t.type === 'error' ? AlertCircle : t.type === 'info' ? Info : CheckCircle2, 16), t.msg
          ))
        ),

        // MODAL
        showModal && h('div', { className: 'fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4', role: 'dialog', 'aria-modal': 'true' },
          h('div', { className: 'bg-white dark:bg-gray-800 rounded-xl shadow-2xl p-6 max-w-sm w-full space-y-4' },
            h('p', { className: 'text-lg font-semibold text-center' }, modalMessage),
            h('div', { className: 'flex justify-center gap-3' },
              btn({ onClick: () => { if (modalCallback) modalCallback() }, className: 'px-6 py-2 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 font-semibold' }, 'Confirm'),
              btn({ onClick: () => { setShowModal(false); setModalCallback(null) }, className: 'px-6 py-2 bg-gray-200 dark:bg-gray-600 text-gray-800 dark:text-gray-200 rounded-lg hover:bg-gray-300 dark:hover:bg-gray-500 font-semibold' }, 'Cancel')
            )
          )
        ),

        // FOOTER
        h('footer', { className: 'text-center text-xs text-gray-400 py-4' }, 'Gemini Translator v', VERSION, ' · Powered by Gemini, DeepL & LibreTranslate')
    }

    const root = document.getElementById('root');
    if (root) ReactDOM.createRoot(root).render(h(ErrorBoundary, null, h(App)));
  </script>
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./sw.js').then(registration => {
          console.log('ServiceWorker registration successful with scope: ', registration.scope);
        }, err => {
          console.log('ServiceWorker registration failed: ', err);
        });
      });
    }
  </script>
</body>

</html>